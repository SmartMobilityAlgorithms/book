

<!DOCTYPE html>


<html lang="en" >

  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.18.1: http://docutils.sourceforge.net/" />

    <title>Informed Search Algorithms &#8212; AI Search Algorithms for Smart Mobility</title>
  
  
  
  <script data-cfasync="false">
    document.documentElement.dataset.mode = localStorage.getItem("mode") || "";
    document.documentElement.dataset.theme = localStorage.getItem("theme") || "light";
  </script>
  
  <!-- Loaded before other Sphinx assets -->
  <link href="../../_static/styles/theme.css?digest=e353d410970836974a52" rel="stylesheet" />
<link href="../../_static/styles/bootstrap.css?digest=e353d410970836974a52" rel="stylesheet" />
<link href="../../_static/styles/pydata-sphinx-theme.css?digest=e353d410970836974a52" rel="stylesheet" />

  
  <link href="../../_static/vendor/fontawesome/6.1.2/css/all.min.css?digest=e353d410970836974a52" rel="stylesheet" />
  <link rel="preload" as="font" type="font/woff2" crossorigin href="../../_static/vendor/fontawesome/6.1.2/webfonts/fa-solid-900.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../../_static/vendor/fontawesome/6.1.2/webfonts/fa-brands-400.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../../_static/vendor/fontawesome/6.1.2/webfonts/fa-regular-400.woff2" />

    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css" />
    <link rel="stylesheet" href="../../_static/styles/sphinx-book-theme.css?digest=14f4ca6b54d191a8c7657f6c759bf11a5fb86285" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../../_static/togglebutton.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/mystnb.4510f1fc1dee50b3e5859aac5469c37c29e427902b24a333a5f9fcb2f0b3ac41.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/sphinx-thebe.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/tabs.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/design-style.4045f2051d55cab465a707391d5b2007.min.css" />
  
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="../../_static/scripts/bootstrap.js?digest=e353d410970836974a52" />
<link rel="preload" as="script" href="../../_static/scripts/pydata-sphinx-theme.js?digest=e353d410970836974a52" />

    <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
    <script src="../../_static/jquery.js"></script>
    <script src="../../_static/underscore.js"></script>
    <script src="../../_static/_sphinx_javascript_frameworks_compat.js"></script>
    <script src="../../_static/doctools.js"></script>
    <script src="../../_static/clipboard.min.js"></script>
    <script src="../../_static/copybutton.js"></script>
    <script src="../../_static/scripts/sphinx-book-theme.js?digest=5a5c038af52cf7bc1a1ec88eea08e6366ee68824"></script>
    <script src="../../_static/tabs.js"></script>
    <script>let toggleHintShow = 'Click to show';</script>
    <script>let toggleHintHide = 'Click to hide';</script>
    <script>let toggleOpenOnPrint = 'true';</script>
    <script src="../../_static/togglebutton.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
    <script src="../../_static/design-tabs.js"></script>
    <script>const THEBE_JS_URL = "https://unpkg.com/thebe@0.8.2/lib/index.js"
const thebe_selector = ".thebe,.cell"
const thebe_selector_input = "pre"
const thebe_selector_output = ".output, .cell_output"
</script>
    <script async="async" src="../../_static/sphinx-thebe.js"></script>
    <script>window.MathJax = {"options": {"processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
    <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script>DOCUMENTATION_OPTIONS.pagename = 'content/GraphSearchAlgorithms/InformedSearch';</script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="Search Algorithm Comparison" href="SearchComparison.html" />
    <link rel="prev" title="Blind Search Algorithms" href="BlindSearch.html" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <meta name="docsearch:language" content="en"/>
  </head>
  
  
  <body data-bs-spy="scroll" data-bs-target=".bd-toc-nav" data-offset="180" data-bs-root-margin="0px 0px -60%" data-default-mode="">

  
  
  <a class="skip-link" href="#main-content">Skip to main content</a>
  
  <input type="checkbox"
          class="sidebar-toggle"
          name="__primary"
          id="__primary"/>
  <label class="overlay overlay-primary" for="__primary"></label>
  
  <input type="checkbox"
          class="sidebar-toggle"
          name="__secondary"
          id="__secondary"/>
  <label class="overlay overlay-secondary" for="__secondary"></label>
  
  <div class="search-button__wrapper">
    <div class="search-button__overlay"></div>
    <div class="search-button__search-container">
<form class="bd-search d-flex align-items-center"
      action="../../search.html"
      method="get">
  <i class="fa-solid fa-magnifying-glass"></i>
  <input type="search"
         class="form-control"
         name="q"
         id="search-input"
         placeholder="Search this book..."
         aria-label="Search this book..."
         autocomplete="off"
         autocorrect="off"
         autocapitalize="off"
         spellcheck="false"/>
  <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd>K</kbd></span>
</form></div>
  </div>
  
    <nav class="bd-header navbar navbar-expand-lg bd-navbar">
    </nav>
  
  <div class="bd-container">
    <div class="bd-container__inner bd-page-width">
      
      <div class="bd-sidebar-primary bd-sidebar">
        

  
  <div class="sidebar-header-items sidebar-primary__section">
    
    
    
    
  </div>
  
    <div class="sidebar-primary-items__start sidebar-primary__section">
        <div class="sidebar-primary-item">
  

<a class="navbar-brand logo" href="../../index.html">
  
  
  
  
    
    
      
    
    
    <img src="../../_static/sm.png" class="logo__image only-light" alt="Logo image"/>
    <script>document.write(`<img src="../../_static/sm.png" class="logo__image only-dark" alt="Logo image"/>`);</script>
  
  
</a></div>
        <div class="sidebar-primary-item"><nav class="bd-links" id="bd-docs-nav" aria-label="Main">
    <div class="bd-toc-item navbar-nav active">
        
        <ul class="nav bd-sidenav bd-sidenav__home-link">
            <li class="toctree-l1">
                <a class="reference internal" href="../../index.html">
                    AI Search Algorithms for Smart Mobility
                </a>
            </li>
        </ul>
        <ul class="current nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="../GettingStarted/index.html">Getting Started</a></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../IntroGeoScience/index.html">Introduction to Geospatial Data Science</a><input class="toctree-checkbox" id="toctree-checkbox-1" name="toctree-checkbox-1" type="checkbox"/><label class="toctree-toggle" for="toctree-checkbox-1"><i class="fa-solid fa-chevron-down"></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../IntroGeoScience/SpatialData.html">Spatial Data and Geographic Information System (GIS)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../IntroGeoScience/Projection.html">Projection</a></li>
<li class="toctree-l2"><a class="reference internal" href="../IntroGeoScience/Visualization.html">Visualization</a></li>
</ul>
</li>
<li class="toctree-l1 current active has-children"><a class="reference internal" href="index.html">Graph Search Algorithms</a><input checked="" class="toctree-checkbox" id="toctree-checkbox-2" name="toctree-checkbox-2" type="checkbox"/><label class="toctree-toggle" for="toctree-checkbox-2"><i class="fa-solid fa-chevron-down"></i></label><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="RoadGraph.html">From Road Network to Graph</a></li>
<li class="toctree-l2"><a class="reference internal" href="GraphSearch.html">Graph Search</a></li>
<li class="toctree-l2"><a class="reference internal" href="BlindSearch.html">Blind Search Algorithms</a></li>
<li class="toctree-l2 current active"><a class="current reference internal" href="#">Informed Search Algorithms</a></li>
<li class="toctree-l2"><a class="reference internal" href="SearchComparison.html">Search Algorithm Comparison</a></li>
</ul>
</li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../TrajectoryAlgorithms/index.html">Trajectory-based Algorithms</a><input class="toctree-checkbox" id="toctree-checkbox-3" name="toctree-checkbox-3" type="checkbox"/><label class="toctree-toggle" for="toctree-checkbox-3"><i class="fa-solid fa-chevron-down"></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../TrajectoryAlgorithms/TabuSearch.html">Tabu Search</a></li>
<li class="toctree-l2"><a class="reference internal" href="../TrajectoryAlgorithms/SimulatedAnnealing.html">Simulated Annealing</a></li>
</ul>
</li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../EvolutionaryComputingAlgorithms/index.html">Evolutionary Computing Algorithms</a><input class="toctree-checkbox" id="toctree-checkbox-4" name="toctree-checkbox-4" type="checkbox"/><label class="toctree-toggle" for="toctree-checkbox-4"><i class="fa-solid fa-chevron-down"></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../EvolutionaryComputingAlgorithms/GeneratingInitialPopulations.html">Generating Initial Populations</a></li>
<li class="toctree-l2"><a class="reference internal" href="../EvolutionaryComputingAlgorithms/GeneticAlgorithms.html">Genetic Algorithms</a></li>
</ul>
</li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../SwarmIntelligenceAlgorithms/index.html">Swarm Intelligence Algorithms</a><input class="toctree-checkbox" id="toctree-checkbox-5" name="toctree-checkbox-5" type="checkbox"/><label class="toctree-toggle" for="toctree-checkbox-5"><i class="fa-solid fa-chevron-down"></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../SwarmIntelligenceAlgorithms/ParticleSwarmOptimization.html">Particle Swarm Optimization</a></li>
<li class="toctree-l2"><a class="reference internal" href="../SwarmIntelligenceAlgorithms/AntColonyOptimization.html">Ant Colony Optimization</a></li>
<li class="toctree-l2"><a class="reference internal" href="../SwarmIntelligenceAlgorithms/ArtificialBeeColony.html">Artificial Bee Colony</a></li>
<li class="toctree-l2"><a class="reference internal" href="../SwarmIntelligenceAlgorithms/FireflyAlgorithm.html">Firefly Algorithm</a></li>
</ul>
</li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../LearnToSearch/index.html">Learn to Search</a><input class="toctree-checkbox" id="toctree-checkbox-6" name="toctree-checkbox-6" type="checkbox"/><label class="toctree-toggle" for="toctree-checkbox-6"><i class="fa-solid fa-chevron-down"></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../LearnToSearch/GeometricDeepLearning.html">Geometric Deep Learning</a></li>
<li class="toctree-l2"><a class="reference internal" href="../LearnToSearch/GraphNeuralNetworks.html">Graph Neural Networks (GNN)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../LearnToSearch/AttentionMechanisms.html">Attention Mechanisms</a></li>
<li class="toctree-l2"><a class="reference internal" href="../LearnToSearch/ReinforcementLearning.html">Reinforcement Learning</a></li>
</ul>
</li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../PeopleMobilityProblems/index.html">People Mobility Problems</a><input class="toctree-checkbox" id="toctree-checkbox-7" name="toctree-checkbox-7" type="checkbox"/><label class="toctree-toggle" for="toctree-checkbox-7"><i class="fa-solid fa-chevron-down"></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../PeopleMobilityProblems/carsharing/CarSharing.html">Car-Sharing Service</a></li>
<li class="toctree-l2"><a class="reference internal" href="../PeopleMobilityProblems/trip_itinerary_planning/TIP.html">Trip Itinerary Planning</a></li>
<li class="toctree-l2"><a class="reference internal" href="../PeopleMobilityProblems/multicriteriarouting/MultiCriteriaRouting.html">Multi-Criteria Routing</a></li>
<li class="toctree-l2"><a class="reference internal" href="../PeopleMobilityProblems/deadheading/Deadheading.html">Deadheading in Ride-Hailing</a></li>

</ul>
</li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../LogisticsProblems/index.html">Logistics Problems</a><input class="toctree-checkbox" id="toctree-checkbox-8" name="toctree-checkbox-8" type="checkbox"/><label class="toctree-toggle" for="toctree-checkbox-8"><i class="fa-solid fa-chevron-down"></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../LogisticsProblems/delivery_GA.html">Delivery Vehicle Routing</a></li>
<li class="toctree-l2"><a class="reference internal" href="../LogisticsProblems/eco_routing.html">Eco-efficient Delivery</a></li>
</ul>
</li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../InfrastructureProblems/index.html">Infrastructure Problems</a><input class="toctree-checkbox" id="toctree-checkbox-9" name="toctree-checkbox-9" type="checkbox"/><label class="toctree-toggle" for="toctree-checkbox-9"><i class="fa-solid fa-chevron-down"></i></label><ul>
<li class="toctree-l2"><a class="reference internal" href="../InfrastructureProblems/emergency_vehicle/emergency_vehicle.html">Emergency Dispatch and Routing</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../ToolsAndPythonLibraries/index.html">Tools and Python Libraries</a></li>
<li class="toctree-l1"><a class="reference internal" href="../Datasets.html">Datasets</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../References.html">References</a></li>
</ul>

    </div>
</nav></div>
    </div>
  
  
  <div class="sidebar-primary-items__end sidebar-primary__section">
  </div>
  
  <div id="rtd-footer-container"></div>


      </div>
      
      <main id="main-content" class="bd-main">
        
        

<div class="sbt-scroll-pixel-helper"></div>

          <div class="bd-content">
            <div class="bd-article-container">
              
              <div class="bd-header-article">
<div class="header-article-items header-article__inner">
  
    <div class="header-article-items__start">
      
        <div class="header-article-item"><label class="sidebar-toggle primary-toggle btn btn-sm" for="__primary" title="Toggle primary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
  <span class="fa-solid fa-bars"></span>
</label></div>
      
    </div>
  
  
    <div class="header-article-items__end">
      
        <div class="header-article-item">

<div class="article-header-buttons">


<a href="https://github.com/SmartMobilityAlgorithms/book" target="_blank"
   class="btn btn-sm btn-source-repository-button"
   title="Source repository"
   data-bs-placement="bottom" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fab fa-github"></i>
  </span>

</a>






<div class="dropdown dropdown-download-buttons">
  <button class="btn dropdown-toggle" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-label="Download this page">
    <i class="fas fa-download"></i>
  </button>
  <ul class="dropdown-menu">
      
      
      
      <li><a href="../../_sources/content/GraphSearchAlgorithms/InformedSearch.ipynb" target="_blank"
   class="btn btn-sm btn-download-source-button dropdown-item"
   title="Download source file"
   data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-file"></i>
  </span>
<span class="btn__text-container">.ipynb</span>
</a>
</li>
      
      
      
      
      <li>
<button onclick="window.print()"
  class="btn btn-sm btn-download-pdf-button dropdown-item"
  title="Print to PDF"
  data-bs-placement="left" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-file-pdf"></i>
  </span>
<span class="btn__text-container">.pdf</span>
</button>
</li>
      
  </ul>
</div>




<button onclick="toggleFullScreen()"
  class="btn btn-sm btn-fullscreen-button"
  title="Fullscreen mode"
  data-bs-placement="bottom" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-expand"></i>
  </span>

</button>


<script>
document.write(`
  <button class="theme-switch-button btn btn-sm btn-outline-primary navbar-btn rounded-circle" title="light/dark" aria-label="light/dark" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <span class="theme-switch" data-mode="light"><i class="fa-solid fa-sun"></i></span>
    <span class="theme-switch" data-mode="dark"><i class="fa-solid fa-moon"></i></span>
    <span class="theme-switch" data-mode="auto"><i class="fa-solid fa-circle-half-stroke"></i></span>
  </button>
`);
</script>

<script>
document.write(`
  <button class="btn btn-sm navbar-btn search-button search-button__button" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass"></i>
  </button>
`);
</script>
<label class="sidebar-toggle secondary-toggle btn btn-sm" for="__secondary"title="Toggle secondary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <span class="fa-solid fa-list"></span>
</label>
</div></div>
      
    </div>
  
</div>
</div>
              
              

<div id="jb-print-docs-body" class="onlyprint">
    <h1>Informed Search Algorithms</h1>
    <!-- Table of contents -->
    <div id="print-main-content">
        <div id="jb-print-toc">
            
            <div>
                <h2> Contents </h2>
            </div>
            <nav aria-label="Page">
                <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#minimum-spanning-tree">Minimum Spanning Tree</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#disjoint-sets">Disjoint Sets</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#parent-array">Parent Array</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#find-algorithm">Find Algorithm</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#minimum-spanning-tree-with-kruskal-s-algorithm">Minimum Spanning Tree with Kruskal’s algorithm</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#hill-climbing">Hill Climbing</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#the-function">The function</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#beam-search">Beam Search</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#a-search">A* Search</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#the-heuristic">The Heuristic</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#bi-directional-search">Bi-Directional Search</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#hierarchical-approaches">Hierarchical Approaches</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#highway-hierarchies">Highway Hierarchies</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#contraction-hierarchies">Contraction Hierarchies</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#contraction">Contraction</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#contraction-order">Contraction Order</a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#example-1-bi-directional-dijkstra-with-contraction">Example #1: Bi-directional Dijkstra with contraction</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pruning">Pruning</a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#example-2-equestrian-statue-to-bahen-centre-using-contraction-hierarchy">Example #2: Equestrian Statue to Bahen Centre using Contraction Hierarchy</a></li>
</ul>
</li>
</ul>
            </nav>
        </div>
    </div>
</div>

              
                
<div id="searchbox"></div>
                <article class="bd-article" role="main">
                  
  <section class="tex2jax_ignore mathjax_ignore" id="informed-search-algorithms">
<h1>Informed Search Algorithms<a class="headerlink" href="#informed-search-algorithms" title="Permalink to this heading">#</a></h1>
<p>Informed search algorithms differ from blind search algorithms in the sense that the goal state is already known. Additionally, the algorithms use knowledge during the search in order to guide the search. This knowledge can take the form of distance to target, or incurred costs.</p>
<hr class="docutils" />
<section id="minimum-spanning-tree">
<h2>Minimum Spanning Tree<a class="headerlink" href="#minimum-spanning-tree" title="Permalink to this heading">#</a></h2>
<p>Given a spanning tree <span class="math notranslate nohighlight">\(T\)</span> in a graph <span class="math notranslate nohighlight">\(G\)</span> with a weight <span class="math notranslate nohighlight">\(w\)</span> and edges <span class="math notranslate nohighlight">\(E\)</span>, the weight <span class="math notranslate nohighlight">\(w\)</span> of <span class="math notranslate nohighlight">\(T\)</span> is the sum of weights of its edges. If <span class="math notranslate nohighlight">\(T\)</span> has the minimum weight over all spanning trees of <span class="math notranslate nohighlight">\(G\)</span>, we call <span class="math notranslate nohighlight">\(T\)</span> a <em>minimum spanning tree</em>.</p>
<section id="disjoint-sets">
<h3>Disjoint Sets<a class="headerlink" href="#disjoint-sets" title="Permalink to this heading">#</a></h3>
<p>Before going any further and introducing the algorithm that generates the minimum spanning <span class="math notranslate nohighlight">\(T\)</span> given a graph <span class="math notranslate nohighlight">\(G\)</span>, we need to discuss disjoint sets, like set of vertices <span class="math notranslate nohighlight">\(V\)</span>. The main operations on disjoint sets which are interesting to us are <strong>finding</strong> the set containing a given element and forming the <strong>union</strong> of two sets, like having multiple sets of vertices of different spanning trees.</p>
</section>
<section id="parent-array">
<h3>Parent Array<a class="headerlink" href="#parent-array" title="Permalink to this heading">#</a></h3>
<p>Let’s consider a  set <span class="math notranslate nohighlight">\(S\)</span> which contains all <span class="math notranslate nohighlight">\(n = 12\)</span> vertices of a graph, so <span class="math notranslate nohighlight">\(S = \{0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11\}\)</span>. If we want to partition them into five sets for further processing, into <span class="math notranslate nohighlight">\(k = 5\)</span> <em>disjoint</em> sets, imagine that these disjoint sets represent a single spanning tree in the graph. The vertices set would be <span class="math notranslate nohighlight">\(S = \{\{0, 1, 2\}, \{3, 4\}, \{5, 6, 7, 8\}, \{9, 10\}, \{11\}\}\)</span>. We need to be quick in maintaining these sets, so we need to refer to each set by the root of the given disjoint set (root of the tree).</p>
<p>Here we introduce the idea of maintaining a parent array that stores the parent of each element (node). The root won’t have a parent so its value in the parent array would be <span class="math notranslate nohighlight">\(-1\)</span>. Here is an example of the set above, think about them as trees in the graph.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">figures</span> <span class="kn">import</span> <span class="o">*</span>
<span class="n">disjoint_forest</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../../_images/55baf24d1030f3ad8cffb23b736e923978b21e78831a04790890dae9be862d38.png" src="../../_images/55baf24d1030f3ad8cffb23b736e923978b21e78831a04790890dae9be862d38.png" />
</div>
</div>
<p>For <span class="math notranslate nohighlight">\(V[i], i = 0,1,2, ... , 11\)</span>
$<span class="math notranslate nohighlight">\(V[i]      =  [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]\)</span><span class="math notranslate nohighlight">\(
\)</span><span class="math notranslate nohighlight">\(Parent[i] =  [-1, 0, 0, -1, 3, -1, 5, 5, 5, 10, -1, -1]\)</span>$</p>
<p>So now we have a forest <span class="math notranslate nohighlight">\(F\)</span> from the set of vertices <span class="math notranslate nohighlight">\(S\)</span> and in <span class="math notranslate nohighlight">\(F\)</span>/<span class="math notranslate nohighlight">\(S\)</span> we have multiple trees/disjoint sets…</p>
</section>
<section id="find-algorithm">
<h3>Find Algorithm<a class="headerlink" href="#find-algorithm" title="Permalink to this heading">#</a></h3>
<p>Given a vertex <span class="math notranslate nohighlight">\(i\)</span> in a certain tree/disjoint set, we want to know the root of that tree.</p>
<p><strong>FIND</strong>(Parent[0:n-1], i, r) <strong>returns</strong> The root (<em>r</em>) of disjoint set that contains V[i]<br />
 <em>r</em> ← <em>V[i]</em></p>
<p> <strong>while</strong> Parent[<em>r</em>] &gt;= 0 <strong>do</strong></p>
<p>  <em>r</em> ← Parent[<em>r</em>]</p>
<p> <strong>endwhile</strong></p>
<p> <strong>return</strong> <em>r</em></p>
</section>
<section id="minimum-spanning-tree-with-kruskal-s-algorithm">
<h3>Minimum Spanning Tree with Kruskal’s algorithm<a class="headerlink" href="#minimum-spanning-tree-with-kruskal-s-algorithm" title="Permalink to this heading">#</a></h3>
<p><strong>KRUSKAL_MST</strong>(graph) <strong>returns</strong> a set <em>MST</em> contains edges of the tree<br />
 <em>Forest</em> ← {}<br />
 <em>Size</em> ← 0<br />
 <strong>for</strong> <em>i</em> ← 0 <strong>to</strong> n-1 <strong>do</strong><br />
   <em>Parent[i]</em> ← -1<br />
 <strong>endfor</strong><br />
 <em>j</em> ← 0<br />
 <strong>while</strong>  <em>Size</em> &lt;= n-1 <strong>and</strong> <em>j</em> &lt; <em>m</em> <strong>do</strong> # <em>m</em> is the number of edges of set <em>E</em> = {e<sub>i</sub> = u<sub>i</sub>v<sub>i</sub> | <em>i</em> in {1,…,<em>m</em>}}<br />
  <em>j</em> ← <em>j</em> + 1<br />
  FIND(<em>Parent</em>[0:n-1],<em>u</em><sub>j</sub>,<em>r</em>)<br />
  FIND(<em>Parent</em>[0:n-1],<em>v</em><sub>j</sub>,<em>s</em>)<br />
  <strong>if</strong> <em>r</em> ≠ <em>s</em> <strong>then</strong><br />
   <em>Forest</em> ← <em>Forest</em> ∐ {<em>e</em><sub>j</sub>}<br />
   <em>Size</em> ← <em>Size</em> + 1<br />
   UNION(<em>Parent</em> [0:n-1],<em>r</em>,<em>s</em>)<br />
  <strong>endif</strong>
 <strong>endwhile</strong>
 <em>MST</em> ← <em>Forest</em><br />
 <strong>return</strong> <em>MST</em></p>
<p>Let’s find the MST for all nodes in our search space (surrounding the University of Toronto).
Here are some things to keep in mind:</p>
<ul class="simple">
<li><p>The graph may seem like a one big connected component but it actually isn’t. There are one-way streets which seem to connect the adjacent nodes on the graph, but in reality they are not connected (you can go from A to B but not in reverse).</p></li>
<li><p>This will result in multiple MST at the end of the algorithm, one for each connected component.</p></li>
<li><p>There may appear to loops in the MST, which is a major violation of tree-like structures. Recall however that what may seem like loops may just be one-way streets.</p></li>
</ul>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">networkx</span>
<span class="kn">import</span> <span class="nn">osmnx</span>
<span class="kn">from</span> <span class="nn">matplotlib.collections</span> <span class="kn">import</span> <span class="n">LineCollection</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="kn">from</span> <span class="nn">smart_mobility_utilities.problem</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">utils</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">queue</span> <span class="kn">import</span> <span class="n">PriorityQueue</span>

<span class="n">reference</span> <span class="o">=</span> <span class="p">(</span><span class="mf">43.661667</span><span class="p">,</span> <span class="o">-</span><span class="mf">79.395</span><span class="p">)</span>
<span class="n">G</span> <span class="o">=</span> <span class="n">osmnx</span><span class="o">.</span><span class="n">graph_from_point</span><span class="p">(</span><span class="n">reference</span><span class="p">,</span> <span class="n">dist</span><span class="o">=</span><span class="mi">300</span><span class="p">,</span> <span class="n">clean_periphery</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">simplify</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">osmnx</span><span class="o">.</span><span class="n">plot_graph</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output traceback highlight-ipythontb notranslate"><div class="highlight"><pre><span></span><span class="gt">---------------------------------------------------------------------------</span>
<span class="ne">ModuleNotFoundError</span><span class="g g-Whitespace">                       </span>Traceback (most recent call last)
<span class="nn">Input In [2],</span> in <span class="ni">&lt;cell line: 5&gt;</span><span class="nt">()</span>
<span class="g g-Whitespace">      </span><span class="mi">3</span> <span class="kn">from</span> <span class="nn">matplotlib.collections</span> <span class="kn">import</span> <span class="n">LineCollection</span>
<span class="g g-Whitespace">      </span><span class="mi">4</span> <span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="ne">----&gt; </span><span class="mi">5</span> <span class="kn">from</span> <span class="nn">smart_mobility_utilities.problem</span> <span class="kn">import</span> <span class="o">*</span>
<span class="g g-Whitespace">      </span><span class="mi">6</span> <span class="kn">from</span> <span class="nn">utils</span> <span class="kn">import</span> <span class="o">*</span>
<span class="g g-Whitespace">      </span><span class="mi">7</span> <span class="kn">from</span> <span class="nn">queue</span> <span class="kn">import</span> <span class="n">PriorityQueue</span>

<span class="ne">ModuleNotFoundError</span>: No module named &#39;smart_mobility_utilities&#39;
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Collect x,y coordinates for each node (for visualization purposes later)</span>
<span class="n">node_Xs</span> <span class="o">=</span> <span class="p">[</span><span class="nb">float</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="s1">&#39;x&#39;</span><span class="p">)]</span>
<span class="n">node_Ys</span> <span class="o">=</span> <span class="p">[</span><span class="nb">float</span><span class="p">(</span><span class="n">y</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="s1">&#39;y&#39;</span><span class="p">)]</span>

<span class="n">Edges</span> <span class="o">=</span> <span class="n">PriorityQueue</span><span class="p">()</span>

<span class="k">for</span> <span class="n">source</span><span class="p">,</span> <span class="n">destination</span><span class="p">,</span> <span class="n">data</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">edges</span><span class="p">(</span><span class="n">keys</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="n">Edges</span><span class="o">.</span><span class="n">put</span><span class="p">((</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;length&#39;</span><span class="p">],</span><span class="n">source</span><span class="p">,</span><span class="n">destination</span><span class="p">))</span>

<span class="c1"># Disjoint set to manage loops</span>
<span class="n">nodes_set</span> <span class="o">=</span> <span class="p">{}</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">Edges</span><span class="o">.</span><span class="n">queue</span><span class="p">:</span>
    <span class="n">nodes_set</span><span class="p">[</span><span class="n">i</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
    <span class="n">nodes_set</span><span class="p">[</span><span class="n">i</span><span class="p">[</span><span class="mi">2</span><span class="p">]]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Returns -1 if the node has not been attached to another node during this run</span>
<span class="k">def</span> <span class="nf">find_parent</span><span class="p">(</span><span class="n">node</span><span class="p">):</span>
    <span class="n">r</span> <span class="o">=</span> <span class="n">node</span>
    <span class="k">while</span> <span class="n">nodes_set</span><span class="p">[</span><span class="n">r</span><span class="p">]</span> <span class="o">&gt;=</span><span class="mi">0</span><span class="p">:</span>
        <span class="n">r</span> <span class="o">=</span> <span class="n">nodes_set</span><span class="p">[</span><span class="n">r</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">r</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># The algorithm itself:</span>
<span class="n">Forest</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
<span class="n">Size</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">j</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">m</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">Edges</span><span class="o">.</span><span class="n">queue</span><span class="p">)</span>
<span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">)</span>
<span class="k">while</span> <span class="n">Size</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="ow">and</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">m</span><span class="p">:</span>
    <span class="n">j</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="c1"># the shortest edge till this point</span>
    <span class="n">edge</span> <span class="o">=</span> <span class="n">Edges</span><span class="o">.</span><span class="n">queue</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
    <span class="n">node1</span> <span class="o">=</span> <span class="n">edge</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">node2</span> <span class="o">=</span> <span class="n">edge</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
    <span class="n">parent1</span> <span class="o">=</span> <span class="n">find_parent</span><span class="p">(</span><span class="n">node1</span><span class="p">)</span>
    <span class="n">parent2</span> <span class="o">=</span> <span class="n">find_parent</span><span class="p">(</span><span class="n">node2</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">parent1</span> <span class="o">!=</span> <span class="n">parent2</span><span class="p">:</span>
        <span class="n">Forest</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">edge</span><span class="p">)</span>
        <span class="n">Size</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">nodes_set</span><span class="p">[</span><span class="n">node1</span><span class="p">]</span> <span class="o">=</span> <span class="n">node2</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Visualization</span>
<span class="n">sources</span> <span class="o">=</span> <span class="p">[</span><span class="n">edge</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="n">Forest</span><span class="p">]</span>
<span class="n">destinations</span> <span class="o">=</span> <span class="p">[</span><span class="n">edge</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="n">Forest</span><span class="p">]</span>

<span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span>  <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">15</span><span class="p">,</span> <span class="mi">11</span><span class="p">))</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_facecolor</span><span class="p">(</span><span class="s1">&#39;w&#39;</span><span class="p">)</span>
<span class="n">lines</span> <span class="o">=</span> <span class="p">[]</span>
<span class="n">colorS</span> <span class="o">=</span> <span class="p">[]</span>
<span class="n">widthS</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">for</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">data</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">edges</span><span class="p">(</span><span class="n">keys</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="k">if</span> <span class="s1">&#39;geometry&#39;</span> <span class="ow">in</span> <span class="n">data</span><span class="p">:</span>
            <span class="n">xs</span><span class="p">,</span> <span class="n">ys</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;geometry&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">xy</span>
            <span class="n">lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">xs</span><span class="p">,</span> <span class="n">ys</span><span class="p">)))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">x1</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">u</span><span class="p">][</span><span class="s1">&#39;x&#39;</span><span class="p">]</span>
            <span class="n">y1</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">u</span><span class="p">][</span><span class="s1">&#39;y&#39;</span><span class="p">]</span>
            <span class="n">x2</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">v</span><span class="p">][</span><span class="s1">&#39;x&#39;</span><span class="p">]</span>
            <span class="n">y2</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">v</span><span class="p">][</span><span class="s1">&#39;y&#39;</span><span class="p">]</span>
            <span class="n">line</span> <span class="o">=</span> <span class="p">[(</span><span class="n">x1</span><span class="p">,</span> <span class="n">y1</span><span class="p">),</span> <span class="p">(</span><span class="n">x2</span><span class="p">,</span> <span class="n">y2</span><span class="p">)]</span>
            <span class="n">lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">line</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">u</span> <span class="ow">in</span> <span class="n">sources</span> <span class="ow">and</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">destinations</span><span class="p">:</span>
            <span class="n">colorS</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;b&#39;</span><span class="p">)</span>
            <span class="n">widthS</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mf">2.5</span><span class="p">)</span>
            <span class="k">continue</span>
        <span class="k">if</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">sources</span> <span class="ow">and</span> <span class="n">u</span> <span class="ow">in</span> <span class="n">destinations</span><span class="p">:</span>
            <span class="n">colorS</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;b&#39;</span><span class="p">)</span>
            <span class="n">widthS</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mf">2.5</span><span class="p">)</span>
            <span class="k">continue</span>
        <span class="n">colorS</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;r&#39;</span><span class="p">)</span>
        <span class="n">widthS</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mf">0.4</span><span class="p">)</span>    
<span class="n">lc</span> <span class="o">=</span> <span class="n">LineCollection</span><span class="p">(</span><span class="n">lines</span><span class="p">,</span> <span class="n">colors</span><span class="o">=</span><span class="n">colorS</span><span class="p">,</span> <span class="n">linewidths</span><span class="o">=</span><span class="n">widthS</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.3</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">add_collection</span><span class="p">(</span><span class="n">lc</span><span class="p">)</span>
<span class="n">scat</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">node_Xs</span><span class="p">,</span> <span class="n">node_Ys</span><span class="p">,</span><span class="n">c</span><span class="o">=</span><span class="s1">&#39;k&#39;</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../../_images/b4164066b7b75cc14c559be7b077169085ae25bb2af0f965dc05a290f9b7fd90.png" src="../../_images/b4164066b7b75cc14c559be7b077169085ae25bb2af0f965dc05a290f9b7fd90.png" />
</div>
</div>
</section>
</section>
<hr class="docutils" />
<section id="hill-climbing">
<h2>Hill Climbing<a class="headerlink" href="#hill-climbing" title="Permalink to this heading">#</a></h2>
<p>The idea of the algorithm is quite simple:</p>
<p>Starting with a known (non-optimized) solution to a function, the algorithm checks the neighbours of that solution, and chooses the neighbour that is “more” optimized. The process is repeated until no “better” solution can be found, at which point the algorithm terminates.</p>
<p>While the algorithm works relatively well with <strong>convex</strong> problems, functions with multiple local maxima will often result in an answer that is not the global maximum. It also performs poorly when there are plateaus (a local set of solutions that are all similarly optimized).</p>
<style>
i {font-weight:normal}
span {font-weight:normal}
</style>
<div style="background-color: rgba(0,0,0,0.0470588);padding:10px;font-family:monospace;">
    <b>HILL-CLIMBING</b>(<i>source</i>,<i>destination</i>) <b>return</b> a <i>route</i>
    <div style='padding-left:20px;'>
        <i><font color="green">current</font></i> &larr; random <i>route</i> from <i>source</i> to <i>destination</i><br>
        <i><font color="orange">neighbours</font></i> &larr; children of <i><font color="green">current</font></i><br><br>
        while min(<i><font color="orange">neighbours</font></i>) < <i><font color="green">current</font></i> do
        <div style='padding-left:20px;'>
            <i><font color="green">current</font></i> &larr; min(<i><font color="orange">neighbours</font></i>)<br>
            <i><font color="orange">neighbours</font></i> &larr; children of <i><font color="green">current</font></i>
        </div>
        return <i><font color="green">current</font></i>
    </div>
</div>
<br><br><p>Here, we introduce a few new ideas.</p>
<p>First, we treat the route between two nodes as a function, the value of which is the distance between the two nodes.
Second, we generate “children” of this function.</p>
<hr class="docutils" />
<section id="the-function">
<h3>The function<a class="headerlink" href="#the-function" title="Permalink to this heading">#</a></h3>
<p>We need to define a function <span class="math notranslate nohighlight">\(f\)</span> that is our target for optimization. <br><br>
<span class="math notranslate nohighlight">\(f(x)\)</span> gives us the length of a route for some given route <span class="math notranslate nohighlight">\(x \in Y\)</span>, where <span class="math notranslate nohighlight">\(Y\)</span> is the set of all possible routes between two specific nodes.</p>
<p>How do we generate <span class="math notranslate nohighlight">\(x\)</span>? We could just generate random permutations between the two nodes, filtering for permutations that are feasible, and optimize <span class="math notranslate nohighlight">\(f\)</span> over these random, sparse permutations.</p>
<p>However, this method is not reproducible (because the permutations change every run).</p>
<p>Instead, we make a deterministic policy that generates a number of <span class="math notranslate nohighlight">\(x \in Y\)</span> by successively “failing” nodes between the source and destination nodes. We then find the shortest path between the nodes before and after the “failed” nodes.</p>
<p>By failing the nodes in a deterministic fashion, we can say that we have a function and neighbourhood with defined size for a certain value so we can “rigorously” conduct a local search.</p>
<p>To generate our initial route and children routes, we will use the <code class="docutils literal notranslate"><span class="pre">smart_mobility_utilities</span></code> package. You can see how these routes are generated by consulting the documentation for that package.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Setup the Graph, origin, and destination</span>
<span class="kn">from</span> <span class="nn">smart_mobility_utilities.common</span> <span class="kn">import</span> <span class="n">Node</span>
<span class="kn">from</span> <span class="nn">smart_mobility_utilities.viz</span> <span class="kn">import</span> <span class="n">draw_route</span>

<span class="n">reference</span> <span class="o">=</span> <span class="p">(</span><span class="mf">43.661667</span><span class="p">,</span> <span class="o">-</span><span class="mf">79.395</span><span class="p">)</span>
<span class="n">G</span> <span class="o">=</span> <span class="n">osmnx</span><span class="o">.</span><span class="n">graph_from_point</span><span class="p">(</span><span class="n">reference</span><span class="p">,</span> <span class="n">dist</span><span class="o">=</span><span class="mi">300</span><span class="p">,</span> <span class="n">clean_periphery</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">simplify</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

<span class="n">origin</span> <span class="o">=</span> <span class="n">Node</span><span class="p">(</span><span class="n">graph</span><span class="o">=</span><span class="n">G</span><span class="p">,</span> <span class="n">osmid</span><span class="o">=</span><span class="mi">55808290</span><span class="p">)</span>
<span class="n">destination</span> <span class="o">=</span> <span class="n">Node</span><span class="p">(</span><span class="n">graph</span><span class="o">=</span><span class="n">G</span><span class="p">,</span> <span class="n">osmid</span><span class="o">=</span><span class="mi">389677909</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">smart_mobility_utilities.common</span> <span class="kn">import</span> <span class="n">randomized_search</span><span class="p">,</span> <span class="n">cost</span>
<span class="kn">from</span> <span class="nn">smart_mobility_utilities.children</span> <span class="kn">import</span> <span class="n">get_children</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="kn">from</span> <span class="nn">tqdm.notebook</span> <span class="kn">import</span> <span class="n">tqdm</span>

<span class="c1"># Progress bar as this algorithm can take a long time</span>
<span class="n">pbar</span> <span class="o">=</span> <span class="n">tqdm</span><span class="p">()</span>
<span class="c1"># Visualize the costs over time</span>
<span class="n">costs</span> <span class="o">=</span> <span class="p">[]</span>
<span class="c1"># Set the number of children to generate</span>
<span class="n">num_children</span> <span class="o">=</span> <span class="mi">20</span>

<span class="n">current</span> <span class="o">=</span> <span class="n">randomized_search</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">origin</span><span class="o">.</span><span class="n">osmid</span><span class="p">,</span> <span class="n">destination</span><span class="o">.</span><span class="n">osmid</span><span class="p">)</span>
<span class="n">costs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cost</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">current</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Initial cost:&quot;</span><span class="p">,</span><span class="n">costs</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

<span class="n">neighbours</span> <span class="o">=</span> <span class="n">get_children</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">current</span><span class="p">,</span><span class="n">num_children</span><span class="o">=</span><span class="n">num_children</span><span class="p">)</span>
<span class="n">shortest</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">neighbours</span> <span class="p">,</span> <span class="n">key</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">route</span> <span class="p">:</span> <span class="n">cost</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">route</span><span class="p">))</span>

<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Initial min(children):&quot;</span><span class="p">,</span><span class="n">cost</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">shortest</span><span class="p">))</span>
<span class="k">while</span> <span class="n">cost</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">shortest</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">cost</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">current</span><span class="p">):</span>
    <span class="n">pbar</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">current</span> <span class="o">=</span> <span class="n">shortest</span>
    <span class="n">neighbours</span> <span class="o">=</span> <span class="n">get_children</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">current</span><span class="p">,</span><span class="n">num_children</span><span class="o">=</span><span class="n">num_children</span><span class="p">)</span>
    <span class="n">shortest</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">neighbours</span> <span class="p">,</span> <span class="n">key</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">route</span> <span class="p">:</span> <span class="n">cost</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">route</span><span class="p">))</span>
    <span class="n">costs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cost</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">current</span><span class="p">))</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Current cost:&quot;</span><span class="p">,</span><span class="n">costs</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span><span class="s2">&quot;|&quot;</span><span class="p">,</span><span class="s2">&quot;min(children):&quot;</span><span class="p">,</span><span class="n">cost</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">shortest</span><span class="p">))</span>

<span class="n">route</span> <span class="o">=</span> <span class="n">current</span>

<span class="n">plt</span><span class="o">.</span><span class="n">xticks</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">costs</span><span class="p">)))</span>
<span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s2">&quot;Hill climbing: Shortest Path&quot;</span><span class="p">)</span>
<span class="n">p</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">costs</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Final cost:&quot;</span><span class="p">,</span><span class="n">costs</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<script type="application/vnd.jupyter.widget-view+json">{"model_id": "968fdf347cfc4775838a7ce5eeb91e95", "version_major": 2, "version_minor": 0}</script><div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Initial cost: 915.06
Initial min(children): 869.566
Current cost: 869.566 | min(children): 915.06
Final cost: 869.566
</pre></div>
</div>
<img alt="../../_images/0c7fa80b1cbdb9594f31c44609309fea6e645272eee3861d15ed7da9e0acbfdb.png" src="../../_images/0c7fa80b1cbdb9594f31c44609309fea6e645272eee3861d15ed7da9e0acbfdb.png" />
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">draw_route</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">route</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<script type="application/vnd.jupyter.widget-view+json">{"model_id": "f46e227c108749d5841b82f3fb4ca49c", "version_major": 2, "version_minor": 0}</script></div>
</div>
<p>While the implementation above is deterministic in nature, the initial route is still randomized. That means that it’s possible to get different results across runs.</p>
<p>Hill climbing will generally return some decent results as there are few local optimal points in the route function. However, with larger search spaces that will naturally have more local maxima and plateaus, it will get stuck fairly quickly.</p>
</section>
</section>
<hr class="docutils" />
<section id="beam-search">
<h2>Beam Search<a class="headerlink" href="#beam-search" title="Permalink to this heading">#</a></h2>
<p>While Hill Climbing maintains a single “best” state throughout the run, beam search keeps <span class="math notranslate nohighlight">\(k\)</span> states in memory. At each iterations, it generates the neighbours for each of the <span class="math notranslate nohighlight">\(k\)</span> states, and puts them into a pool with the <span class="math notranslate nohighlight">\(k\)</span> states from the original beam. It then selects the best <span class="math notranslate nohighlight">\(k\)</span> routes from the pool to become the new beam, and this process repeats. The algorithm terminates when the new beam is equal to the old beam. As it is a local search algorithm, it is also susceptible to being stuck at local maxima.</p>
<p>A beam search with <span class="math notranslate nohighlight">\(k=\infty\)</span> is the same as a BFS. Because there is the risk that a state that would lead to the optimal solution might get discarded, beam searches are considered to be incomplete (it may not terminate with the solution).</p>
<style>
i {font-weight:normal}
span {font-weight:normal}
</style>
<div style="background-color: rgba(0,0,0,0.0470588);padding:10px;font-family:monospace;">
    <b>BEAM-SEARCH</b>(<i>source</i>,<i>destination</i>,<i>k</i>) <b>return</b> a <i>route</i>
    <div style='padding-left:20px;'>
        <i><font color="green">seen</font></i> &larr; <i>nil</i><br>
        <i><font color="orange">beam</font></i> &larr; random <i>k</i> routes from <i>source</i> to <i>destination</i><br>
        add <i><font color="orange">beam</font></i> to <i><font color="green">seen</font></i><br>
        <i><font color="purple">pool</font></i> &larr; children of routes in the <i><font color="orange">beam</font></i> with consideration of <i><font color="green">seen</font></i> + <i><font color="orange">beam</font></i><br>
        <i><font color="grey">last_beam</font></i> &larr; <i>nil</i><br><br>
        while <i><font color="orange">beam</font></i> is not <i><font color="grey">last_beam</font></i> do
        <div style='padding-left:20px;'>
            <i><font color="grey">last_beam</font></i> &larr; <i><font color="orange">beam</font></i><br>
            <i><font color="orange">beam</font></i> &larr; the best <i>k</i> routes from <i><font color="purple">pool</font></i><br>
            add <i><font color="orange">beam</font></i> to <i><font color="green">seen</font></i><br>
            <i><font color="purple">pool</font></i> &larr; children of routes in the <i><font color="orange">beam</font></i> with consideration of <i><font color="green">seen</font></i> + <i><font color="orange">beam</font></i>
        </div>
        <b>return</b> optimal <i>route</i> in <i><font color="orange">beam</font></i>
    </div>
</div>
<br><br><div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">heapq</span>
<span class="kn">from</span> <span class="nn">smart_mobility_utilities.children</span> <span class="kn">import</span> <span class="n">get_beam</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>

<span class="c1"># Progress bar as this algorithm can take a long time</span>
<span class="n">pbar</span> <span class="o">=</span> <span class="n">tqdm</span><span class="p">()</span>
<span class="c1"># Initialize</span>
<span class="n">seen</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
<span class="n">k</span> <span class="o">=</span> <span class="mi">10</span>
<span class="n">num_neighbours</span> <span class="o">=</span> <span class="mi">10</span>
<span class="n">costs</span> <span class="o">=</span> <span class="p">[]</span>

<span class="n">beam</span> <span class="o">=</span> <span class="p">[</span><span class="n">randomized_search</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">origin</span><span class="o">.</span><span class="n">osmid</span><span class="p">,</span><span class="n">destination</span><span class="o">.</span><span class="n">osmid</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">k</span><span class="p">)]</span>

<span class="c1"># the seen routes must be converted to a tuple to be hashable to be stored in a set</span>
<span class="k">for</span> <span class="n">route</span> <span class="ow">in</span> <span class="n">beam</span><span class="p">:</span> <span class="n">seen</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">route</span><span class="p">))</span>

<span class="n">pool</span> <span class="o">=</span> <span class="p">[]</span>
<span class="n">children</span> <span class="o">=</span> <span class="n">get_beam</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">beam</span><span class="p">,</span><span class="n">num_neighbours</span><span class="p">)</span>
<span class="n">costs</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">cost</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">r</span><span class="p">)</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">beam</span><span class="p">])</span>
<span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="n">children</span><span class="p">:</span>
    <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">child</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">r</span><span class="p">)</span> <span class="ow">in</span> <span class="n">seen</span><span class="p">:</span> <span class="k">continue</span>
        <span class="k">else</span><span class="p">:</span> 
            <span class="n">pool</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>
            <span class="n">seen</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">r</span><span class="p">))</span>
<span class="n">pool</span> <span class="o">+=</span> <span class="n">beam</span>
<span class="n">last_beam</span> <span class="o">=</span> <span class="kc">None</span>
<span class="k">while</span> <span class="n">beam</span> <span class="o">!=</span> <span class="n">last_beam</span><span class="p">:</span>
    <span class="n">pbar</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">last_beam</span> <span class="o">=</span> <span class="n">beam</span>
    <span class="n">beam</span> <span class="o">=</span> <span class="n">heapq</span><span class="o">.</span><span class="n">nsmallest</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">pool</span><span class="p">,</span> <span class="n">key</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">route</span><span class="p">:</span> <span class="n">cost</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">route</span><span class="p">))</span>
    
    <span class="k">for</span> <span class="n">route</span> <span class="ow">in</span> <span class="n">beam</span><span class="p">:</span> <span class="n">seen</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">route</span><span class="p">))</span>    
    
    <span class="n">pool</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">children</span> <span class="o">=</span> <span class="n">get_beam</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">beam</span><span class="p">,</span><span class="n">num_neighbours</span><span class="p">)</span>
    <span class="n">costs</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">cost</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">r</span><span class="p">)</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">beam</span><span class="p">])</span>
    <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="n">children</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">child</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">r</span><span class="p">)</span> <span class="ow">in</span> <span class="n">seen</span><span class="p">:</span> <span class="k">continue</span>
            <span class="k">else</span><span class="p">:</span> <span class="n">pool</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">r</span><span class="p">);</span> <span class="n">seen</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">r</span><span class="p">))</span>
    <span class="n">pool</span> <span class="o">+=</span> <span class="n">beam</span>   
<span class="n">route</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">beam</span><span class="p">,</span> <span class="n">key</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">route</span> <span class="p">:</span> <span class="n">cost</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">route</span><span class="p">))</span> 


<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Route:&quot;</span><span class="p">,</span><span class="n">route</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Cost:&quot;</span><span class="p">,</span> <span class="n">cost</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">route</span><span class="p">))</span>

<span class="n">costs</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="nb">list</span><span class="p">,</span><span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="n">costs</span><span class="p">))</span>
<span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">costs</span><span class="p">:</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s2">&quot;Beam Search: Costs vs time&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<script type="application/vnd.jupyter.widget-view+json">{"model_id": "e0aaaf56add447ee90da6cad428aafd8", "version_major": 2, "version_minor": 0}</script><div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Route: [55808290, 304891685, 55808284, 1252869817, 55808239, 389678268, 4953810915, 389678267, 24960090, 389678273, 24959523, 50885177, 389677947, 2143489692, 2480712846, 389678140, 389678139, 389678138, 3707407638, 730029011, 730029007, 2557539842, 123347786, 389678133, 389677909]
Cost: 822.524
</pre></div>
</div>
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Text(0.5, 1.0, &#39;Beam Search: Costs vs time&#39;)
</pre></div>
</div>
<img alt="../../_images/5fdf3ba4dfb8c9956c64129dcd143bfad9295c3a981c444cf993780909cbc508.png" src="../../_images/5fdf3ba4dfb8c9956c64129dcd143bfad9295c3a981c444cf993780909cbc508.png" />
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">draw_route</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">route</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<script type="application/vnd.jupyter.widget-view+json">{"model_id": "3c6f2ccfb52340fc843da28f3bf451d7", "version_major": 2, "version_minor": 0}</script></div>
</div>
</section>
<hr class="docutils" />
<section id="a-search">
<h2>A* Search<a class="headerlink" href="#a-search" title="Permalink to this heading">#</a></h2>
<p>A* (pronounced A-star) search is an informed search algorithm widely used in pathfinding and graph traversal.</p>
<p>A* works by “greedily” choosing which vertex to explore next, based on a function:</p>
<p><span class="math notranslate nohighlight">\(f(V) = h(V) + g(V)\)</span>, where <span class="math notranslate nohighlight">\(h\)</span> is a heuristic, and <span class="math notranslate nohighlight">\(g\)</span> is the cost accrued up to that point.</p>
<style>
i {font-weight:normal}
span {font-weight:normal}
</style>
<div style="background-color: rgba(0,0,0,0.0470588);padding:10px;font-family:monospace;">
    <b>A* Heuristic</b> &larr; sum of straight-line distance between the node to source and node to destination<br>
    <b>PQ</b> &larr; min heap according to <b>A* Heuristic</b><br><br>
    <b>A*-SEARCH</b>(<i>source</i>,<i>destination</i>) <b>return</b> a <i>route</i>
    <div style='padding-left:20px;'>
        <i><font color="green">frontier</font></i> &larr; a <b>PQ</b> initialized with <i>source</i><br>
        <i><font color="grey">explored</font></i> &larr; <i>empty</i><br>
        <i><font color="orange">found</font></i> &larr; <i>False</i><br>
        while <i><font color="green">frontier</font></i> is not <i>empty</i> and <i><font color="orange">found</font></i> is <i>False</i> do
        <div style='padding-left:20px;'>
        <i>node</i> &larr; <i><font color="green">frontier</font></i>.pop()<br>
        add <i>node</i> to <i><font color="grey">explored</font></i><br>
        for <i>child</i> in <i>node</i>.expand() do
            <div style='padding-left:20px;'>
                if <i>child</i> is not in <i><font color="grey">explored</font></i> and <i>child</i> is not in <i><font color="green">frontier</font></i> then
                <div style='padding-left:20px;'>
                if <i>child</i> is <i>destination</i> then
                    <div style='padding-left:20px;'>
                        <i>route</i> &larr; <i>child</i>.route()<br>
                        <i><font color="orange">found</font></i> &larr; <i>True</i>
                    </div>
                add <i>child</i> to <i><font color="green">frontier</font></i>
                </div>
            </div>
        </div>
    return <i>route</i>
    </div>
</div>
<br><br><section id="the-heuristic">
<h3>The Heuristic<a class="headerlink" href="#the-heuristic" title="Permalink to this heading">#</a></h3>
<p>The driving force behind A* is the selection of a new vertex (or node) to explore based on the lowest heuristic value. This heuristic value is computed by the following formula:</p>
<p>let <span class="math notranslate nohighlight">\(dist(x,y)\)</span> be a function that calculates the straight line distance between two nodes <span class="math notranslate nohighlight">\(x,y\)</span>,<br>
and let <span class="math notranslate nohighlight">\(O\)</span> be the origin node, and <span class="math notranslate nohighlight">\(D\)</span> be the destination node,</p>
<p><span class="math notranslate nohighlight">\(h(V) = dist(V,O) + dist(V,D)\)</span> for any given node <span class="math notranslate nohighlight">\(V\)</span></p>
<p>As the sum of the distance to the origin and destination is minimized when <span class="math notranslate nohighlight">\(V\)</span> lies on a straight line from <span class="math notranslate nohighlight">\(O\)</span> to <span class="math notranslate nohighlight">\(D\)</span>, this heuristic prioritizes nodes which are “closer” to the straight-line distance from origin to destination.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The implentation of the A* heuristic in <code class="docutils literal notranslate"><span class="pre">smart_mobility_utilities</span></code> defaults to calculating distances as if the Earth were flat. For local searches, this yields the best results. If the size of the search area is larger, it is better to calculate distance using the <code class="docutils literal notranslate"><span class="pre">haversine_distance</span></code>, which takes into account the curvature of the Earth.</p>
<p>This can be done by setting the distance function like so:<br>
<code class="docutils literal notranslate"><span class="pre">astar_heuristic(G,origin.osmid,destination.osmid,</span> <span class="pre">measuring_dist</span> <span class="pre">=</span> <span class="pre">haversine_distance)</span></code></p>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Get the A* Heuristic for all the nodes in the graph</span>
<span class="kn">from</span> <span class="nn">smart_mobility_utilities.problem</span> <span class="kn">import</span> <span class="n">astar_heuristic</span>

<span class="k">def</span> <span class="nf">A_Star</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">origin</span><span class="p">,</span> <span class="n">destination</span><span class="p">):</span>
    <span class="n">toOrigin</span><span class="p">,</span> <span class="n">toDestination</span> <span class="o">=</span> <span class="n">astar_heuristic</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">origin</span><span class="o">.</span><span class="n">osmid</span><span class="p">,</span> <span class="n">destination</span><span class="o">.</span><span class="n">osmid</span><span class="p">)</span>
    <span class="n">route</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">frontier</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
    <span class="n">frontier</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">origin</span><span class="p">)</span>
    <span class="n">explored</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
    <span class="n">found</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="k">while</span> <span class="n">frontier</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">found</span><span class="p">:</span>   
        <span class="c1"># choose a node based on its heuristic value</span>
        <span class="n">node</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">frontier</span><span class="p">,</span> <span class="n">key</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">node</span> <span class="p">:</span> <span class="n">toOrigin</span><span class="p">[</span><span class="n">node</span><span class="o">.</span><span class="n">osmid</span><span class="p">]</span> <span class="o">+</span> <span class="n">toDestination</span><span class="p">[</span><span class="n">node</span><span class="o">.</span><span class="n">osmid</span><span class="p">])</span>
        <span class="n">frontier</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
        <span class="n">explored</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
        <span class="c1"># expand its children</span>
        <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">expand</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">child</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">explored</span> <span class="ow">and</span> <span class="n">child</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">frontier</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">child</span> <span class="o">==</span> <span class="n">destination</span><span class="p">:</span>
                    <span class="n">route</span> <span class="o">=</span> <span class="n">child</span><span class="o">.</span><span class="n">path</span><span class="p">()</span>
                    <span class="n">found</span> <span class="o">=</span> <span class="kc">True</span>
                    <span class="k">continue</span>
                <span class="n">frontier</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">child</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">route</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">route</span> <span class="o">=</span> <span class="n">A_Star</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">origin</span><span class="p">,</span> <span class="n">destination</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Route: </span><span class="si">{</span><span class="n">route</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Cost: </span><span class="si">{</span><span class="n">cost</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">route</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="n">draw_route</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">route</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Route: [55808290, 304891685, 55808284, 1252869817, 55808239, 389678268, 4953810915, 389678267, 24960090, 389678273, 1258698113, 389678151, 389678142, 2143489694, 389678141, 2143488528, 389678140, 389678139, 389678138, 3707407638, 6028561924, 6028561921, 389678131, 6028562356, 854322047, 389677908, 749952029, 389677909]
Cost: 839.904
</pre></div>
</div>
<script type="application/vnd.jupyter.widget-view+json">{"model_id": "ef1c26e46e1e4533b1337ccbe972ed52", "version_major": 2, "version_minor": 0}</script></div>
</div>
</section>
</section>
<hr class="docutils" />
<section id="bi-directional-search">
<h2>Bi-Directional Search<a class="headerlink" href="#bi-directional-search" title="Permalink to this heading">#</a></h2>
<p>The purpose of bi-directional searches are to run two simultaneous, non-parallel searches; one starts at the origin and the other at the destination, with the goal of meeting somewhere in between.</p>
<p>This approach is more efficient because of the time complexities involved.</p>
<p>For example, a BFS search with a constant branching factor <span class="math notranslate nohighlight">\(b\)</span> and depth <span class="math notranslate nohighlight">\(d\)</span> would have an overall space complexity of <span class="math notranslate nohighlight">\(O(d^b)\)</span>. By running two BFS searches in opposite directions with only half the depth (<span class="math notranslate nohighlight">\(d/2\)</span>), the space complexity becomes instead <span class="math notranslate nohighlight">\(O((d/2)^b)+O((d/2)^b)\)</span>, which is much lower than the original <span class="math notranslate nohighlight">\(O(d^b)\)</span>.</p>
<style>
i {font-weight:normal}
span {font-weight:normal}
</style>
<div style="background-color: rgba(0,0,0,0.0470588);padding:10px;font-family:monospace;">
    <b>BI-DIRECTIONAL-SEARCH</b>(<i>source</i>,<i>destination</i>) <b>return</b> a <i>route</i>
    <div style='padding-left:20px;'>
        <font color="#03A9F4">// _f for forward, _b for backward</font><br>
        <i><font color="green">frontier_f</font></i> &larr; initialized with <i>source</i><br>
        <i><font color="green">frontier_b</font></i> &larr; initialized with <i>destination</i><br>
        <i><font color="grey">explored_f</font></i> &larr; <i>empty</i><br>
        <i><font color="grey">explored_b</font></i> &larr; <i>empty</i><br>
        <i><font color="orange">found</font></i> &larr; <i>False</i><br>
        <i><font color="purple">collide</font></i> &larr; <i>False</i> <font color="#03A9F4">// if front overlaps with back</font><br>
        <i><font color="blue">found</font></i> &larr; <i>False</i><br>
        <i><font color="blue">altr_expand</font></i> &larr; <i>False</i><font color="#03A9F4">// expansion direction</font><br><br>
        while <i><font color="green">frontier_f</font></i> is not <i>empty</i> and <i><font color="green">frontier_b</font></i> is not <i>empty</i> and not <i><font color="purple">collide</font></i> and not <i><font color="orange">found</font></i> do
        <div style='padding-left:20px;'>
            if <i><font color="blue">altr_expand</font></i> then
            <div style='padding-left:20px;'>
                <i>node</i> &larr; <i><font color="green">frontier_f</font></i>.pop()<br>
                add <i>node</i> to <i><font color="grey">explored_f</font></i><br>
                for <i>child</i> in <i>node</i>.expand() do
                <div style='padding-left:20px;'>
                    if <i>child</i> in <i><font color="grey">explored_f</font></i> then continue<br>
                    if <i>child</i> is <i>destination</i> then
                        <div style='padding-left:20px;'>
                            <i>route</i> &larr; <i>child</i>.route()<br>
                            <i><font color="orange">found</font></i> &larr; <i>True</i>
                        </div>
                    if <i>child</i> in <i><font color="grey">explored_b</font></i> then
                        <div style='padding-left:20px;'>
                            <i>route</i> &larr; <i>child</i>.route() + reverse(<i>overlapped</i>.route())<br>
                            <i><font color="purple">collide</font></i> &larr; <i>True</i>
                        </div>
                    add <i>child</i> to <i><font color="green">frontier_f</font></i><br>
                    <i><font color="blue">altr_expand</font></i> &larr; not <i><font color="blue">altr_expand</font></i>
                </div>
            </div>
            else
            <div style='padding-left:20px;'>
                <i>node</i> &larr; <i><font color="green">frontier_b</font></i>.pop()<br>
                add <i>node</i> to <i><font color="grey">explored_b</font></i><br>
                for <i>child</i> in <i>node</i>.expand() do
                <div style='padding-left:20px;'>
                    if <i>child</i> in <i><font color="grey">explored_b</font></i> then continue<br>
                    if <i>child</i> is <i>origin</i> then
                        <div style='padding-left:20px;'>
                            <i>route</i> &larr; <i>child</i>.route()<br>
                            <i><font color="orange">found</font></i> &larr; <i>True</i>
                    </div>
                    if <i>child</i> in <i><font color="grey">explored_f</font></i> then
                        <div style='padding-left:20px;'>
                            <i>route</i> &larr; reverse(<i>child</i>.route()) + <i>overlapped</i>.route()<br>
                            <i><font color="purple">collide</font></i> &larr; <i>True</i>
                        </div>
                    add <i>child</i> to <i><font color="green">frontier_b</font></i><br>
                    <i><font color="blue">altr_expand</font></i> &larr; not <i><font color="blue">altr_expand</font></i>
                </div>
            </div>
        </div>
        return <i>route</i>
    </div>
</div>
<br><br><div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Using A* as search heuristic and algorithm</span>

<span class="c1"># define destination and origin for the backwards expansion</span>
<span class="n">destination_b</span> <span class="o">=</span> <span class="n">origin</span>
<span class="n">origin_b</span> <span class="o">=</span> <span class="n">destination</span>

<span class="c1"># get A*</span>
<span class="n">toOrigin_f</span><span class="p">,</span> <span class="n">toDestination_f</span> <span class="o">=</span> <span class="n">astar_heuristic</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">origin</span><span class="o">.</span><span class="n">osmid</span><span class="p">,</span> <span class="n">destination</span><span class="o">.</span><span class="n">osmid</span><span class="p">)</span>
<span class="n">toOrigin_b</span><span class="p">,</span> <span class="n">toDestination_b</span> <span class="o">=</span> <span class="n">astar_heuristic</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">origin_b</span><span class="o">.</span><span class="n">osmid</span><span class="p">,</span> <span class="n">destination_b</span><span class="o">.</span><span class="n">osmid</span><span class="p">)</span>

<span class="n">route</span> <span class="o">=</span> <span class="p">[]</span>

<span class="n">f_value</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">node</span><span class="p">:</span> <span class="n">toOrigin_f</span><span class="p">[</span><span class="n">node</span><span class="o">.</span><span class="n">osmid</span><span class="p">]</span> <span class="o">+</span> <span class="n">toDestination_f</span><span class="p">[</span><span class="n">node</span><span class="o">.</span><span class="n">osmid</span><span class="p">]</span>
<span class="n">b_value</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">node</span><span class="p">:</span> <span class="n">toOrigin_b</span><span class="p">[</span><span class="n">node</span><span class="o">.</span><span class="n">osmid</span><span class="p">]</span> <span class="o">+</span> <span class="n">toDestination_b</span><span class="p">[</span><span class="n">node</span><span class="o">.</span><span class="n">osmid</span><span class="p">]</span>

<span class="n">frontier_f</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
<span class="n">frontier_b</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>

<span class="n">frontier_f</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">origin</span><span class="p">)</span>
<span class="n">frontier_b</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">origin_b</span><span class="p">)</span>

<span class="n">explored_f</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
<span class="n">explored_b</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>

<span class="n">collide</span> <span class="o">=</span> <span class="kc">False</span>
<span class="n">found</span> <span class="o">=</span> <span class="kc">False</span>
<span class="n">altr_expand</span> <span class="o">=</span> <span class="kc">False</span> <span class="c1"># to alternate between front and back</span>

<span class="k">while</span> <span class="n">frontier_f</span> <span class="ow">and</span> <span class="n">frontier_b</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">collide</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">found</span><span class="p">:</span>
   
    <span class="k">if</span> <span class="n">altr_expand</span><span class="p">:</span>
        <span class="c1"># remove node_f from frontier_f to expand it</span>
        <span class="n">node</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">frontier_f</span><span class="p">,</span> <span class="n">key</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">node</span> <span class="p">:</span> <span class="n">f_value</span><span class="p">(</span><span class="n">node</span><span class="p">))</span>
        <span class="n">frontier_f</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
        <span class="n">explored_f</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
        
        <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">expand</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">child</span> <span class="ow">in</span> <span class="n">explored_f</span><span class="p">:</span> <span class="k">continue</span>
            
            <span class="k">if</span> <span class="n">child</span> <span class="o">==</span> <span class="n">destination</span><span class="p">:</span>
                <span class="n">route</span> <span class="o">=</span> <span class="n">child</span><span class="o">.</span><span class="n">path</span><span class="p">()</span>
                <span class="n">found</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">break</span>

            <span class="c1"># checking for collusion with the target expansion</span>
            <span class="k">if</span> <span class="n">child</span> <span class="ow">in</span> <span class="n">explored_b</span><span class="p">:</span>
                <span class="n">overlapped</span> <span class="o">=</span> <span class="nb">next</span><span class="p">((</span><span class="n">node</span> <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">explored_b</span> <span class="k">if</span> <span class="n">node</span> <span class="o">==</span> <span class="n">child</span><span class="p">))</span>
                <span class="c1"># we don&#39;t take the overlapped node twice</span>
                <span class="n">route</span> <span class="o">=</span> <span class="n">child</span><span class="o">.</span><span class="n">path</span><span class="p">()[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">overlapped</span><span class="o">.</span><span class="n">path</span><span class="p">()[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">collide</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">break</span>

            <span class="n">frontier_f</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">child</span><span class="p">)</span>
        <span class="n">altr_expand</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># remove node_b from frontier_b to expand it</span>
        <span class="n">node</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">frontier_b</span><span class="p">,</span> <span class="n">key</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">node</span> <span class="p">:</span> <span class="n">b_value</span><span class="p">(</span><span class="n">node</span><span class="p">))</span>
        <span class="n">frontier_b</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
        <span class="n">explored_b</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
        
        <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">expand</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">child</span> <span class="ow">in</span> <span class="n">explored_b</span><span class="p">:</span> <span class="k">continue</span>
            <span class="k">if</span> <span class="n">child</span> <span class="o">==</span> <span class="n">destination_b</span><span class="p">:</span>
                <span class="n">route</span> <span class="o">=</span> <span class="n">child</span><span class="o">.</span><span class="n">path</span><span class="p">()[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="c1"># we reverse the list because we expand from the back</span>
                <span class="n">found</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">break</span>

            <span class="k">if</span> <span class="n">child</span> <span class="ow">in</span> <span class="n">explored_f</span><span class="p">:</span>
                <span class="n">overlapped</span> <span class="o">=</span> <span class="nb">next</span><span class="p">((</span><span class="n">node</span> <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">explored_f</span> <span class="k">if</span> <span class="n">node</span> <span class="o">==</span> <span class="n">child</span><span class="p">),</span> <span class="kc">None</span><span class="p">)</span>
                <span class="n">route</span> <span class="o">=</span> <span class="n">overlapped</span><span class="o">.</span><span class="n">path</span><span class="p">()[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">child</span><span class="o">.</span><span class="n">path</span><span class="p">()[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">collide</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">break</span>

            <span class="n">frontier_b</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">child</span><span class="p">)</span>
        <span class="n">altr_expand</span> <span class="o">=</span> <span class="kc">True</span>

<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;The route is </span><span class="se">\n\n</span><span class="s2">&quot;</span><span class="p">,</span><span class="n">route</span><span class="p">)</span>
<span class="n">route_cost</span> <span class="o">=</span> <span class="n">cost</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">route</span><span class="p">[:</span><span class="mi">17</span><span class="p">])</span>
<span class="n">second_half</span> <span class="o">=</span> <span class="n">route</span><span class="p">[</span><span class="mi">17</span><span class="p">:]</span>
<span class="n">second_half</span><span class="o">.</span><span class="n">reverse</span><span class="p">()</span>
<span class="n">route_cost</span> <span class="o">+=</span> <span class="n">cost</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">second_half</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Cost of the route:&quot;</span><span class="p">,</span><span class="n">route_cost</span><span class="p">)</span>
<span class="n">draw_route</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">route</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>The route is 

 [55808290, 304891685, 55808284, 1252869817, 55808239, 389678268, 4953810915, 389678267, 24960090, 389678273, 1258698113, 389678151, 389678142, 2143489694, 389678141, 2143488528, 389678140, 249991437, 3707407641, 24960080, 6028561924, 6028561921, 389678131, 6028562356, 854322047, 389677908, 749952029, 389677909]
Cost of the route: 827.505
</pre></div>
</div>
<script type="application/vnd.jupyter.widget-view+json">{"model_id": "1f980a593add4a4fb4edb9918d5b66db", "version_major": 2, "version_minor": 0}</script></div>
</div>
<p>Why is the cost of the final route calculated manually above? That’s because our bi-directional implementation assumes that for every edge <span class="math notranslate nohighlight">\(u,v\)</span>, there exists an edge <span class="math notranslate nohighlight">\(v,u\)</span>, but this is not the case in reality. For example, some streets may be unidirectional (i.e. one-way streets) or have turning restrictions. In our case, there is no edge that connects <code class="docutils literal notranslate"><span class="pre">2143489694</span></code> to <code class="docutils literal notranslate"><span class="pre">389678141</span></code>, but an edge does exist in the reverse direction.</p>
<p>How can we fix this? If we assume that we are routing for the purpose of pedestrian transit, unidirectional edges essentially act as bidirectional edges and there is no real issue. We then simple need to calculate the route cost from the origin to the node before the offending node, and add the cost from the destination to the node before the offending node, as below. For more complicated routing problems involving vehicles, we can instead implement various methods to ignore unidirectional edges for the reverse path (from destination to origin) that would avoid this problem entirely.</p>
</section>
<hr class="docutils" />
<section id="hierarchical-approaches">
<h2>Hierarchical Approaches<a class="headerlink" href="#hierarchical-approaches" title="Permalink to this heading">#</a></h2>
<p>When facing routing problems at larger scales, such as those involving entire continents or graphs with millions of nodes, it is simply implausible to use basic approaches like Dijkstra or DFS. Instead, routing algorithms “prune” the search space in order to simplify the routing problem. Additionally, routing services may choose to precompute certain routes and cache them on servers, so that response times to user queries are reasonable.</p>
<p>Hierarchical search algorithms prune the search space by generating admissible heuristics that abstract the search space. Read more about the general approach of hierarchical methods at <a class="reference external" href="https://www.aaai.org/ocs/index.php/SOCS/SOCS11/paper/viewFile/4035/4363">Faster Optimal and Suboptimal Hierarchical Search</a>.</p>
<p>In this section, we’ll give a brief overview of two hierarchical approaches that aim to solve the shortest path problem, and show how their heuristics are computed. There will also be a <code class="docutils literal notranslate"><span class="pre">python</span></code> implementation of the Contraction Hierarchies example.</p>
<hr class="docutils" />
<section id="highway-hierarchies">
<h3>Highway Hierarchies<a class="headerlink" href="#highway-hierarchies" title="Permalink to this heading">#</a></h3>
<p>In this algorithm, the hierarchy “level” of each road/arc in the graph is calculated. This distinguishes the type of road segment (i.e. residential, national roads, highways). This is further supplemented by relevant data such as maximum designated driving speed, as well as number of turns in the road. After the heuristics are generated for the graph, the data is passed through a modified search function (bi-directional Dijkstra, A*, etc) that considers the distance to the destination and the potential expansion node class.</p>
<p>For example, the algorithm will generally consider highways as viable expansion nodes when it is still relatively further away from the target, and then will start to include national roads, and finally residential streets as it nears the destination.</p>
<p>While this approach “makes sense”, there are some disadvantages. First, the algorithm largely overlooks what kind of roads humans “prefer” to drive on. That is to say, which a highway might make sense for a given route, the user may “prefer” to take local roads (i.e. driving to a friend’s house who lives nearby). Secondly, highway hierarchies do not take into account factors such as traffic, which fluctuates often and adds significant cost to an “optimal” route.</p>
<p>You can learn more about contraction hierarchies <a class="reference external" href="https://link.springer.com/chapter/10.1007/11561071_51">here</a>.</p>
</section>
<hr class="docutils" />
<section id="contraction-hierarchies">
<h3>Contraction Hierarchies<a class="headerlink" href="#contraction-hierarchies" title="Permalink to this heading">#</a></h3>
<p>While the highway hierarchies algorithm may be useful for speeding up shortest path searches, it only considers three levels of road hierarchies. On the other hand, the contraction hierarchies algorithm introduced by <a class="reference external" href="https://link.springer.com/chapter/10.1007/978-3-540-68552-4_24">Contraction Hierarchies: Faster and Simpler Hierarchical Routing in Road Networks</a> has the same number of hierarchies as nodes in the graph, which is beneficial as increased number of hierarchies results in more pruning of the search space.</p>
<section id="contraction">
<h4>Contraction<a class="headerlink" href="#contraction" title="Permalink to this heading">#</a></h4>
<p>Taking any node <span class="math notranslate nohighlight">\(V\)</span> from a graph <span class="math notranslate nohighlight">\(G\)</span>, remove <span class="math notranslate nohighlight">\(V\)</span> as well as any connected edges. <br>
Add any number of edges to <span class="math notranslate nohighlight">\(G\)</span> such that the shortest distance for any pair of neighbouring nodes remains the same, even after <span class="math notranslate nohighlight">\(V\)</span> has been removed. Below is an example:<br>
<img alt="" src="../../_images/uncontract.png" /></p>
<p>Suppose we are contracting <strong>Node 1</strong>. By removing the node, we have now changed the shortest path for 0→2, 0→3, and 2→3. We can restore it by creating new edges. After the creation of new edges, we then reinsert any removed nodes and edges. We then update that node with its hierarchy level (which is just the order of contraction, from <span class="math notranslate nohighlight">\(1\)</span> to <span class="math notranslate nohighlight">\(n\)</span>). See the below updated graph:<br><br>
<img alt="" src="../../_images/contract.png" /></p>
<p>This process is then repeated for all the other nodes. In our example, no other nodes need to be contracted, as removing any one of the remaining nodes does not affect the rest of the graph in terms of shortest path. This process will form <strong>shortcuts</strong>, which allow us to search the graph much faster, as we can ignore certain nodes that have been “pruned”.</p>
</section>
<section id="contraction-order">
<h4>Contraction Order<a class="headerlink" href="#contraction-order" title="Permalink to this heading">#</a></h4>
<p>Any order for node contraction will result in a successful algorithm, however some contraction ordering systems minimizes the number of new edges added to the graph, and thus the overall running time.</p>
<p>To utilize this, we can employ the idea of <strong>edge difference (ED)</strong>. The ED of a node is <span class="math notranslate nohighlight">\(S-E\)</span>, where <span class="math notranslate nohighlight">\(S\)</span> is the number of new edges added if that node were to be contracted, and <span class="math notranslate nohighlight">\(E\)</span> is the number of edges that would be deleted. Minimizing ED is equivalent to minimizing the number of new edges added to the graph, and thus improves processing time.</p>
</section>
</section>
<hr class="docutils" />
<section id="example-1-bi-directional-dijkstra-with-contraction">
<h3>Example #1: Bi-directional Dijkstra with contraction<a class="headerlink" href="#example-1-bi-directional-dijkstra-with-contraction" title="Permalink to this heading">#</a></h3>
<p>After contracting a graph, we can run a bi-directional Dijkstra to compute all the shortest paths in the graph. Following this, any queries for the shortest path between any two nodes in the graph can be solved using a cached result.</p>
<p>There are some restrictions for our modified Dijkstra’s:</p>
<ol class="arabic simple">
<li><p>The forward expansion only considers arcs <span class="math notranslate nohighlight">\(u,v\)</span>, where <span class="math notranslate nohighlight">\(level(u) &gt; level(v)\)</span>. This forms the <strong>upward graph</strong>, where only nodes with a higher contraction order can be relaxed.</p></li>
<li><p>The backward expansion only considers arcs <span class="math notranslate nohighlight">\(u,v\)</span>, where <span class="math notranslate nohighlight">\(level(u) &lt; level(v)\)</span>. This forms the <strong>downward graph</strong>, where only nodes with a lower contraction order can be relaxed.</p></li>
</ol>
<p>These restrictions help “prune” the search space and speed up the processing.</p>
<p>At the end, multiple paths are returned from source to destination, of which the shortest is selected to be the solution.</p>
<p>Let’s try this with the sample graph below:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">networkx</span>
<span class="kn">import</span> <span class="nn">math</span>

<span class="n">G</span> <span class="o">=</span> <span class="n">networkx</span><span class="o">.</span><span class="n">Graph</span><span class="p">()</span>

<span class="c1"># Computing each contraction level requires a new graph, which is costly in terms of memory.</span>
<span class="c1"># To avoid this, we use a flag on every node to show its contraction state.</span>

<span class="c1"># Add 14 nodes</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">15</span><span class="p">):</span>
    <span class="n">G</span><span class="o">.</span><span class="n">add_node</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">contracted</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

<span class="c1"># Define the edges</span>
<span class="n">edges</span> <span class="o">=</span> <span class="p">[</span>
    <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,{</span><span class="s1">&#39;weight&#39;</span><span class="p">:</span><span class="mi">1</span><span class="p">}),</span>
    <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,{</span><span class="s1">&#39;weight&#39;</span><span class="p">:</span><span class="mi">4</span><span class="p">}),</span>
    <span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,{</span><span class="s1">&#39;weight&#39;</span><span class="p">:</span><span class="mi">5</span><span class="p">}),</span>
    <span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">,{</span><span class="s1">&#39;weight&#39;</span><span class="p">:</span><span class="mi">2</span><span class="p">}),</span>
    <span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,{</span><span class="s1">&#39;weight&#39;</span><span class="p">:</span><span class="mi">2</span><span class="p">}),</span>
    <span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">7</span><span class="p">,{</span><span class="s1">&#39;weight&#39;</span><span class="p">:</span><span class="mi">2</span><span class="p">}),</span>
    <span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">8</span><span class="p">,{</span><span class="s1">&#39;weight&#39;</span><span class="p">:</span><span class="mi">1</span><span class="p">}),</span>
    <span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">9</span><span class="p">,{</span><span class="s1">&#39;weight&#39;</span><span class="p">:</span><span class="mi">1</span><span class="p">}),</span>
    <span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,{</span><span class="s1">&#39;weight&#39;</span><span class="p">:</span><span class="mi">5</span><span class="p">}),</span>
    <span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="mi">10</span><span class="p">,{</span><span class="s1">&#39;weight&#39;</span><span class="p">:</span><span class="mi">7</span><span class="p">}),</span>
    <span class="p">(</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">,{</span><span class="s1">&#39;weight&#39;</span><span class="p">:</span><span class="mi">4</span><span class="p">}),</span>
    <span class="p">(</span><span class="mi">6</span><span class="p">,</span><span class="mi">8</span><span class="p">,{</span><span class="s1">&#39;weight&#39;</span><span class="p">:</span><span class="mi">3</span><span class="p">}),</span>
    <span class="p">(</span><span class="mi">6</span><span class="p">,</span><span class="mi">10</span><span class="p">,{</span><span class="s1">&#39;weight&#39;</span><span class="p">:</span><span class="mi">3</span><span class="p">}),</span>
    <span class="p">(</span><span class="mi">6</span><span class="p">,</span><span class="mi">5</span><span class="p">,{</span><span class="s1">&#39;weight&#39;</span><span class="p">:</span><span class="mi">3</span><span class="p">}),</span>
    <span class="p">(</span><span class="mi">6</span><span class="p">,</span><span class="mi">9</span><span class="p">,{</span><span class="s1">&#39;weight&#39;</span><span class="p">:</span><span class="mi">1</span><span class="p">}),</span>
    <span class="p">(</span><span class="mi">7</span><span class="p">,</span><span class="mi">8</span><span class="p">,{</span><span class="s1">&#39;weight&#39;</span><span class="p">:</span><span class="mi">6</span><span class="p">}),</span>
    <span class="p">(</span><span class="mi">8</span><span class="p">,</span><span class="mi">9</span><span class="p">,{</span><span class="s1">&#39;weight&#39;</span><span class="p">:</span><span class="mi">3</span><span class="p">}),</span>
    <span class="p">(</span><span class="mi">8</span><span class="p">,</span><span class="mi">13</span><span class="p">,{</span><span class="s1">&#39;weight&#39;</span><span class="p">:</span><span class="mi">5</span><span class="p">}),</span>
    <span class="p">(</span><span class="mi">9</span><span class="p">,</span><span class="mi">12</span><span class="p">,{</span><span class="s1">&#39;weight&#39;</span><span class="p">:</span><span class="mi">1</span><span class="p">}),</span>
    <span class="p">(</span><span class="mi">9</span><span class="p">,</span><span class="mi">10</span><span class="p">,{</span><span class="s1">&#39;weight&#39;</span><span class="p">:</span><span class="mi">3</span><span class="p">}),</span>
    <span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="mi">11</span><span class="p">,{</span><span class="s1">&#39;weight&#39;</span><span class="p">:</span><span class="mi">4</span><span class="p">}),</span>
    <span class="p">(</span><span class="mi">11</span><span class="p">,</span><span class="mi">12</span><span class="p">,{</span><span class="s1">&#39;weight&#39;</span><span class="p">:</span><span class="mi">3</span><span class="p">}),</span>
    <span class="p">(</span><span class="mi">11</span><span class="p">,</span><span class="mi">13</span><span class="p">,{</span><span class="s1">&#39;weight&#39;</span><span class="p">:</span><span class="mi">4</span><span class="p">}),</span>
    <span class="p">(</span><span class="mi">12</span><span class="p">,</span><span class="mi">13</span><span class="p">,{</span><span class="s1">&#39;weight&#39;</span><span class="p">:</span><span class="mi">2</span><span class="p">}),</span>
    <span class="p">(</span><span class="mi">14</span><span class="p">,</span><span class="mi">1</span><span class="p">,{</span><span class="s1">&#39;weight&#39;</span><span class="p">:</span><span class="mi">3</span><span class="p">}),</span>
    <span class="p">(</span><span class="mi">14</span><span class="p">,</span><span class="mi">13</span><span class="p">,{</span><span class="s1">&#39;weight&#39;</span><span class="p">:</span><span class="mi">2</span><span class="p">})</span>
<span class="p">]</span>
<span class="c1"># Add the edges to the graph and visualize it.</span>
<span class="n">G</span><span class="o">.</span><span class="n">add_edges_from</span><span class="p">([</span><span class="o">*</span><span class="n">edges</span><span class="p">])</span>
<span class="n">networkx</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">with_labels</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../../_images/3cb26cadf56e15c496d2c64a9eac306fe9bfafa77f8168eaad74b235c982617e.png" src="../../_images/3cb26cadf56e15c496d2c64a9eac306fe9bfafa77f8168eaad74b235c982617e.png" />
</div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>For this implementation we will be using two helper functions from <code class="docutils literal notranslate"><span class="pre">smart_mobility_utilities.contraction</span></code>.</p>
<p>The first is <code class="docutils literal notranslate"><span class="pre">dijkstra_with_contraction</span></code>, which simple runs a Dijkstra search on a graph, with the condition that the expansion nodes cannot be already contracted.</p>
<p>The second is <code class="docutils literal notranslate"><span class="pre">calculate_edge_difference</span></code>, which calculates the ED for every node in a given graph.</p>
<p>See the API docs for <code class="docutils literal notranslate"><span class="pre">smart_mobility_utilities.contraction</span></code> for more details.</p>
</div>
<p>We will first need to obtain the ED for the input graph:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">dijkstra_with_contraction</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">source</span><span class="p">,</span> <span class="n">destination</span><span class="p">,</span> <span class="n">contracted</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
    <span class="n">networkx</span><span class="o">.</span><span class="n">set_node_attributes</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="p">{</span><span class="n">contracted</span><span class="p">:</span> <span class="kc">True</span><span class="p">},</span> <span class="s1">&#39;contracted&#39;</span><span class="p">)</span>
        
    <span class="n">shortest_path</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
    <span class="n">heap</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
    
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">():</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">networkx</span><span class="o">.</span><span class="n">get_node_attributes</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="s1">&#39;contracted&#39;</span><span class="p">)[</span><span class="n">i</span><span class="p">]:</span>
            <span class="n">shortest_path</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">inf</span>
            <span class="n">heap</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
    <span class="n">shortest_path</span><span class="p">[</span><span class="n">source</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
    
    <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">heap</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        
        <span class="n">q</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">heap</span><span class="p">,</span> <span class="n">key</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">node</span> <span class="p">:</span> <span class="n">shortest_path</span><span class="p">[</span><span class="n">node</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">q</span> <span class="o">==</span> <span class="n">destination</span><span class="p">:</span>
            <span class="n">networkx</span><span class="o">.</span><span class="n">set_node_attributes</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="p">{</span><span class="n">contracted</span><span class="p">:</span> <span class="kc">False</span><span class="p">},</span> <span class="s1">&#39;contracted&#39;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">shortest_path</span><span class="p">[</span><span class="n">q</span><span class="p">]</span>
        <span class="n">heap</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">q</span><span class="p">)</span>
        
        <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">G</span><span class="p">[</span><span class="n">q</span><span class="p">]:</span>
            <span class="c1"># if the node is contracted we skip it</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">networkx</span><span class="o">.</span><span class="n">get_node_attributes</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="s1">&#39;contracted&#39;</span><span class="p">)[</span><span class="n">v</span><span class="p">]:</span>
                <span class="n">distance</span> <span class="o">=</span> <span class="n">shortest_path</span><span class="p">[</span><span class="n">q</span><span class="p">]</span> <span class="o">+</span> <span class="n">G</span><span class="p">[</span><span class="n">q</span><span class="p">][</span><span class="n">v</span><span class="p">][</span><span class="s1">&#39;weight&#39;</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">distance</span> <span class="o">&lt;</span> <span class="n">shortest_path</span><span class="p">[</span><span class="n">v</span><span class="p">]:</span>
                    <span class="n">shortest_path</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="n">distance</span>
                    
    <span class="n">networkx</span><span class="o">.</span><span class="n">set_node_attributes</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="p">{</span><span class="n">contracted</span><span class="p">:</span> <span class="kc">False</span><span class="p">},</span> <span class="s1">&#39;contracted&#39;</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">math</span><span class="o">.</span><span class="n">inf</span> <span class="c1"># if we can&#39;t reach the destination</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">shortest_paths</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">():</span>
    <span class="n">shortest_paths</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">():</span>
        <span class="n">shortest_paths</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">dijkstra_with_contraction</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">calculate_edge_difference</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">shortest_paths</span><span class="p">):</span>
    <span class="n">edge_difference</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
    <span class="n">seenBefore</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
    
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">():</span>
        <span class="c1"># used in edge difference calculations</span>
        <span class="n">edges_incident</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">G</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>

        <span class="c1"># we will be deleting the node entry</span>
        <span class="c1"># from the original shortest paths</span>
        <span class="c1"># dictionary so we need to save its state</span>
        <span class="c1"># for later iterations</span>
        <span class="n">contracted_node_paths</span> <span class="o">=</span> <span class="n">shortest_paths</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="k">del</span> <span class="n">shortest_paths</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        
        <span class="c1"># excluding the node that we have just contracted</span>
        <span class="n">new_graph</span> <span class="o">=</span> <span class="p">[</span><span class="o">*</span><span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">()]</span> 
        <span class="n">new_graph</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
        
        <span class="c1"># let&#39;s compute the new shortest paths between</span>
        <span class="c1"># the nodes of the graph without the contracted</span>
        <span class="c1"># node so we can see the changes and add arcs </span>
        <span class="c1"># to the graph accordingly but that is in</span>
        <span class="c1"># the algorithm itself </span>
        <span class="n">new_shortest_paths</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>

        <span class="k">for</span> <span class="n">source</span> <span class="ow">in</span> <span class="n">new_graph</span><span class="p">:</span>
            <span class="n">new_shortest_paths</span><span class="p">[</span><span class="n">source</span><span class="p">]</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">destination</span> <span class="ow">in</span> <span class="n">new_graph</span><span class="p">:</span>
                <span class="c1"># path the contracted node &quot;i&quot; to compute new shortest paths accordingly</span>
                <span class="n">new_shortest_paths</span><span class="p">[</span><span class="n">source</span><span class="p">][</span><span class="n">destination</span><span class="p">]</span> <span class="o">=</span> <span class="n">dijkstra_with_contraction</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> \
                                                                                    <span class="n">source</span><span class="p">,</span> \
                                                                                    <span class="n">destination</span><span class="p">,</span> \
                                                                                    <span class="n">contracted</span> <span class="o">=</span> <span class="n">i</span><span class="p">)</span>
        <span class="c1"># the add arcs to keep the graph all pairs shortest paths invariant</span>
        <span class="n">shortcuts</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">for</span> <span class="n">source</span> <span class="ow">in</span> <span class="n">new_shortest_paths</span><span class="p">:</span>
            <span class="c1"># we get a copy from the original and the new shortest paths dictionary</span>
            <span class="n">SP_contracted</span> <span class="o">=</span> <span class="n">new_shortest_paths</span><span class="p">[</span><span class="n">source</span><span class="p">]</span>
            <span class="n">SP_original</span> <span class="o">=</span> <span class="n">shortest_paths</span><span class="p">[</span><span class="n">source</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">destination</span> <span class="ow">in</span> <span class="n">SP_contracted</span><span class="p">:</span>
                <span class="c1"># this is statement so we don&#39;t add 2 arcs</span>
                <span class="c1"># for the same pair of nodes </span>
                <span class="k">if</span> <span class="p">[</span><span class="n">source</span><span class="p">,</span> <span class="n">destination</span><span class="p">]</span> <span class="ow">in</span> <span class="n">seenBefore</span><span class="p">:</span> <span class="k">continue</span>
                <span class="n">seenBefore</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">sorted</span><span class="p">((</span><span class="n">source</span><span class="p">,</span><span class="n">destination</span><span class="p">)))</span>
                
                <span class="c1"># if there is a difference between the original SP and</span>
                <span class="c1"># post-contraction SP -- just add new arc</span>
                <span class="k">if</span> <span class="n">SP_contracted</span><span class="p">[</span><span class="n">destination</span><span class="p">]</span> <span class="o">!=</span> <span class="n">SP_original</span><span class="p">[</span><span class="n">destination</span><span class="p">]:</span>
                    <span class="n">shortcuts</span> <span class="o">+=</span> <span class="mi">1</span>
        
        <span class="c1"># let&#39;s leave the dictionary as we took it </span>
        <span class="c1"># from the last iteration</span>
        <span class="n">shortest_paths</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">contracted_node_paths</span>
        
        <span class="c1"># this is the value of the contraction</span>
        <span class="c1"># heuristic for that node</span>
        <span class="n">ED</span> <span class="o">=</span> <span class="n">shortcuts</span> <span class="o">-</span> <span class="n">edges_incident</span>
        <span class="n">edge_difference</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">i</span><span class="p">,</span> <span class="n">ED</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">edge_difference</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">edge_difference</span> <span class="o">=</span> <span class="n">calculate_edge_difference</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">shortest_paths</span><span class="p">)</span>
<span class="n">edge_difference</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">pair</span><span class="p">:</span> <span class="n">pair</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

<span class="n">edge_difference</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>[(8, -5),
 (10, -4),
 (5, -3),
 (7, -3),
 (11, -3),
 (14, 0),
 (2, 2),
 (1, 3),
 (6, 4),
 (13, 5),
 (4, 7),
 (12, 18),
 (3, 26),
 (9, 33)]
</pre></div>
</div>
</div>
</div>
<p>While this is a good start to optimizing the node contraction order, it is by no means perfect. Notice that the ED values calculated above assume the node is the only node removed from the graph. Because we are successively removing every node in the graph, the ED list will potentially become inaccurate after even the first contraction.</p>
<p>Recall however that any arbitrary contraction order results in a successful algorithm. While there are ED heuristics that are able to update the ED list after each contraction, each of them come with their own costs and benefits.</p>
<p>For the purposes of this example, our ED list will be sufficient.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># to keep track of the edges added after the algorithm finishes</span>
<span class="n">edges_before</span> <span class="o">=</span> <span class="p">[</span><span class="o">*</span><span class="n">G</span><span class="o">.</span><span class="n">edges</span><span class="p">()]</span>
<span class="n">current_graph</span> <span class="o">=</span> <span class="p">[</span><span class="o">*</span><span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">()]</span>

<span class="k">for</span> <span class="n">node_ED</span> <span class="ow">in</span> <span class="n">edge_difference</span><span class="p">:</span>
    <span class="n">node</span> <span class="o">=</span> <span class="n">node_ED</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    
    <span class="c1"># now we will contract the given node through all iterations</span>
    <span class="n">networkx</span><span class="o">.</span><span class="n">set_node_attributes</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="p">{</span><span class="n">node</span><span class="p">:</span> <span class="kc">True</span><span class="p">},</span> <span class="s1">&#39;contracted&#39;</span><span class="p">)</span>
    
    <span class="n">new_graph</span> <span class="o">=</span> <span class="n">current_graph</span>
    <span class="n">new_graph</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
    <span class="n">current_shortest_paths</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">source</span> <span class="ow">in</span> <span class="n">new_graph</span><span class="p">:</span>
            <span class="n">current_shortest_paths</span><span class="p">[</span><span class="n">source</span><span class="p">]</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">destination</span> <span class="ow">in</span> <span class="n">new_graph</span><span class="p">:</span>
                <span class="n">current_shortest_paths</span><span class="p">[</span><span class="n">source</span><span class="p">][</span><span class="n">destination</span><span class="p">]</span> <span class="o">=</span> <span class="n">dijkstra_with_contraction</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">source</span><span class="p">,</span> <span class="n">destination</span><span class="p">)</span>
                
    <span class="k">for</span> <span class="n">source</span> <span class="ow">in</span> <span class="n">current_shortest_paths</span><span class="p">:</span>
        <span class="n">SP_contracted</span> <span class="o">=</span> <span class="n">current_shortest_paths</span><span class="p">[</span><span class="n">source</span><span class="p">]</span>
        <span class="n">SP_original</span> <span class="o">=</span> <span class="n">shortest_paths</span><span class="p">[</span><span class="n">source</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">destination</span> <span class="ow">in</span> <span class="n">SP_contracted</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">source</span> <span class="o">==</span> <span class="n">destination</span><span class="p">:</span> <span class="k">continue</span>
            <span class="k">if</span> <span class="n">SP_contracted</span><span class="p">[</span><span class="n">destination</span><span class="p">]</span> <span class="o">!=</span> <span class="n">SP_original</span><span class="p">[</span><span class="n">destination</span><span class="p">]:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Added edge between &quot;</span><span class="p">,</span> <span class="n">source</span><span class="p">,</span> <span class="n">destination</span><span class="p">,</span><span class="s2">&quot; after contracting&quot;</span><span class="p">,</span> <span class="n">node</span><span class="p">)</span>
                
                <span class="n">G</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="n">destination</span><span class="p">,</span> <span class="n">weight</span><span class="o">=</span><span class="n">SP_original</span><span class="p">[</span><span class="n">destination</span><span class="p">])</span>
                
    <span class="n">current_graph</span> <span class="o">=</span> <span class="n">new_graph</span>

<span class="c1"># new edges after adding additional arcs</span>
<span class="n">edges_after</span> <span class="o">=</span> <span class="p">[</span><span class="o">*</span><span class="n">G</span><span class="o">.</span><span class="n">edges</span><span class="p">()]</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;# edges before&quot;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">edges_before</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;# edges after&quot;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">edges_after</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Added edge between  1 13  after contracting 14
Added edge between  2 13  after contracting 14
Added edge between  13 1  after contracting 14
Added edge between  13 2  after contracting 14
Added edge between  1 4  after contracting 2
Added edge between  4 1  after contracting 2
# edges before 26
# edges after 29
</pre></div>
</div>
</div>
</div>
<p>While it may seem like edges are being added twice, this is a simple graph, so adding an edge <code class="docutils literal notranslate"><span class="pre">(b,a)</span></code> when there is already an edge <code class="docutils literal notranslate"><span class="pre">(a,b)</span></code> has no effect.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Visualize the newly created &quot;shortcute&quot; on the graph</span>

<span class="n">added_edges</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">edges_after</span><span class="p">)</span> <span class="o">-</span> <span class="nb">set</span><span class="p">(</span><span class="n">edges_before</span><span class="p">))</span>

<span class="c1"># let&#39;s color these edges and draw the graph again</span>
<span class="n">colors</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;r&#39;</span> <span class="k">if</span> <span class="n">edge</span> <span class="ow">in</span> <span class="n">added_edges</span> <span class="k">else</span> <span class="s1">&#39;k&#39;</span> <span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">edges</span><span class="p">()]</span>
<span class="n">widths</span> <span class="o">=</span> <span class="p">[</span><span class="mi">2</span> <span class="k">if</span> <span class="n">edge</span> <span class="ow">in</span> <span class="n">added_edges</span> <span class="k">else</span> <span class="mi">1</span> <span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">edges</span><span class="p">()]</span>
<span class="n">networkx</span><span class="o">.</span><span class="n">draw_networkx</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">with_labels</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span><span class="n">width</span><span class="o">=</span><span class="n">widths</span><span class="p">,</span> <span class="n">edge_color</span><span class="o">=</span><span class="n">colors</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../../_images/ee4bee53d71fabaecafe7f691d08a96376addbf0e958a1e1ae6ff4d61b7050d4.png" src="../../_images/ee4bee53d71fabaecafe7f691d08a96376addbf0e958a1e1ae6ff4d61b7050d4.png" />
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Reformat ED list to hierarchy for search purposes</span>
<span class="n">hierarchical_order</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
<span class="k">for</span> <span class="n">order</span><span class="p">,</span> <span class="n">node</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">edge_difference</span><span class="p">):</span>
    <span class="n">hierarchical_order</span><span class="p">[</span><span class="n">node</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="n">order</span>
    
<span class="n">hierarchical_order</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>{8: 0,
 10: 1,
 5: 2,
 7: 3,
 11: 4,
 14: 5,
 2: 6,
 1: 7,
 6: 8,
 13: 9,
 4: 10,
 12: 11,
 3: 12,
 9: 13}
</pre></div>
</div>
</div>
</div>
<p>Let’s now find the shortest path from <span class="math notranslate nohighlight">\(8\)</span> to <span class="math notranslate nohighlight">\(12\)</span>, using Dijkstra’s with contraction hierarchy.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">source</span> <span class="o">=</span> <span class="mi">8</span>
<span class="n">destination</span> <span class="o">=</span> <span class="mi">12</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Generating the upward graph</span>

<span class="c1"># initializing </span>
<span class="n">SP_s</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
<span class="n">parent_s</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
<span class="n">unrelaxed_s</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
<span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">():</span>
    <span class="n">SP_s</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">inf</span>
    <span class="n">parent_s</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">unrelaxed_s</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
<span class="n">SP_s</span><span class="p">[</span><span class="n">source</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

<span class="c1"># dijkstra</span>
<span class="k">while</span> <span class="n">unrelaxed_s</span><span class="p">:</span>
    <span class="n">node</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">unrelaxed_s</span><span class="p">,</span> <span class="n">key</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">node</span> <span class="p">:</span> <span class="n">SP_s</span><span class="p">[</span><span class="n">node</span><span class="p">])</span>
    <span class="n">unrelaxed_s</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">SP_s</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">==</span> <span class="n">math</span><span class="o">.</span><span class="n">inf</span><span class="p">:</span> <span class="k">break</span>
    <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="n">G</span><span class="p">[</span><span class="n">node</span><span class="p">]:</span>
        <span class="c1"># skip unqualified edges</span>
        <span class="k">if</span> <span class="n">hierarchical_order</span><span class="p">[</span><span class="n">child</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">hierarchical_order</span><span class="p">[</span><span class="n">node</span><span class="p">]:</span> <span class="k">continue</span>
        <span class="n">distance</span> <span class="o">=</span> <span class="n">SP_s</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">+</span> <span class="n">G</span><span class="p">[</span><span class="n">node</span><span class="p">][</span><span class="n">child</span><span class="p">][</span><span class="s1">&#39;weight&#39;</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">distance</span> <span class="o">&lt;</span> <span class="n">SP_s</span><span class="p">[</span><span class="n">child</span><span class="p">]:</span>
            <span class="n">SP_s</span><span class="p">[</span><span class="n">child</span><span class="p">]</span> <span class="o">=</span> <span class="n">distance</span>
            <span class="n">parent_s</span><span class="p">[</span><span class="n">child</span><span class="p">]</span> <span class="o">=</span> <span class="n">node</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Generating the downward graph</span>

<span class="c1"># initializing </span>
<span class="n">SP_t</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
<span class="n">parent_t</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
<span class="n">unrelaxed_t</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
<span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">():</span>
    <span class="n">SP_t</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">inf</span>
    <span class="n">parent_t</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">unrelaxed_t</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
<span class="n">SP_t</span><span class="p">[</span><span class="n">destination</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

<span class="c1"># dijkstra</span>
<span class="k">while</span> <span class="n">unrelaxed_t</span><span class="p">:</span>
    <span class="n">node</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">unrelaxed_t</span><span class="p">,</span> <span class="n">key</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">node</span> <span class="p">:</span> <span class="n">SP_t</span><span class="p">[</span><span class="n">node</span><span class="p">])</span>
    <span class="n">unrelaxed_t</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">SP_t</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">==</span> <span class="n">math</span><span class="o">.</span><span class="n">inf</span><span class="p">:</span> <span class="k">break</span>
    <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="n">G</span><span class="p">[</span><span class="n">node</span><span class="p">]:</span>
        <span class="c1"># skip unqualified edges</span>
        <span class="k">if</span> <span class="n">hierarchical_order</span><span class="p">[</span><span class="n">child</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">hierarchical_order</span><span class="p">[</span><span class="n">node</span><span class="p">]:</span> <span class="k">continue</span>
        <span class="n">distance</span> <span class="o">=</span> <span class="n">SP_t</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">+</span> <span class="n">G</span><span class="p">[</span><span class="n">node</span><span class="p">][</span><span class="n">child</span><span class="p">][</span><span class="s1">&#39;weight&#39;</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">distance</span> <span class="o">&lt;</span> <span class="n">SP_t</span><span class="p">[</span><span class="n">child</span><span class="p">]:</span>
            <span class="n">SP_t</span><span class="p">[</span><span class="n">child</span><span class="p">]</span> <span class="o">=</span> <span class="n">distance</span>
            <span class="n">parent_t</span><span class="p">[</span><span class="n">child</span><span class="p">]</span> <span class="o">=</span> <span class="n">node</span>
</pre></div>
</div>
</div>
</div>
<p>With these, we now merge the common settled nodes from <code class="docutils literal notranslate"><span class="pre">SP_d</span></code> and <code class="docutils literal notranslate"><span class="pre">SP_s</span></code>, and find the minimum sum of values, This is our shortest path: the collision between the forward and backward expansions.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">minimum</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">inf</span>
<span class="n">merge_node</span> <span class="o">=</span> <span class="kc">None</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">SP_s</span><span class="p">:</span>
    <span class="k">if</span> <span class="n">SP_t</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">math</span><span class="o">.</span><span class="n">inf</span><span class="p">:</span> <span class="k">continue</span>
    <span class="k">if</span> <span class="n">SP_t</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">SP_s</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">minimum</span><span class="p">:</span>
        <span class="n">minimum</span> <span class="o">=</span> <span class="n">SP_t</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">SP_s</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">merge_node</span> <span class="o">=</span> <span class="n">i</span>

<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Minimum:&quot;</span><span class="p">,</span><span class="n">minimum</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Merge node:&quot;</span><span class="p">,</span><span class="n">merge_node</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Minimum: 3
Merge node: 9
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Generate the route by getting the route from source to merge node, and from destination to merge node.</span>
<span class="k">def</span> <span class="nf">route_dijkstra</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
    <span class="n">route</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">while</span> <span class="n">node</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">route</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
        <span class="n">node</span> <span class="o">=</span> <span class="n">parent</span><span class="p">[</span><span class="n">node</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">route</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
<span class="n">route_from_target</span> <span class="o">=</span> <span class="n">route_dijkstra</span><span class="p">(</span><span class="n">parent_t</span><span class="p">,</span> <span class="n">merge_node</span><span class="p">)</span>
<span class="n">route_from_source</span> <span class="o">=</span> <span class="n">route_dijkstra</span><span class="p">(</span><span class="n">parent_s</span><span class="p">,</span> <span class="n">merge_node</span><span class="p">)</span>
<span class="n">route</span> <span class="o">=</span> <span class="n">route_from_source</span> <span class="o">+</span> <span class="n">route_from_target</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">:]</span>
<span class="n">route</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>[8, 3, 9, 12]
</pre></div>
</div>
</div>
</div>
<p>Let’s compare this to <code class="docutils literal notranslate"><span class="pre">networkx</span></code>’s built in solver:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">networkx.algorithms.shortest_paths.weighted</span> <span class="kn">import</span> <span class="n">single_source_dijkstra</span>
<span class="n">single_source_dijkstra</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">source</span><span class="p">,</span> <span class="n">destination</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>(3, [8, 3, 9, 12])
</pre></div>
</div>
</div>
</div>
<section id="pruning">
<h4>Pruning<a class="headerlink" href="#pruning" title="Permalink to this heading">#</a></h4>
<p>We can actually check to see how many nodes were “pruned” from our graph, using the upward and downward graphs generated earlier.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">unvisited</span> <span class="o">=</span> <span class="mi">0</span>
<span class="k">for</span> <span class="n">s_node</span><span class="p">,</span> <span class="n">s_dist</span> <span class="ow">in</span> <span class="n">SP_s</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
    <span class="k">for</span> <span class="n">t_node</span><span class="p">,</span> <span class="n">t_dist</span> <span class="ow">in</span> <span class="n">SP_t</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="k">if</span> <span class="n">s_node</span> <span class="o">==</span> <span class="n">t_node</span> <span class="ow">and</span> <span class="n">s_dist</span> <span class="o">==</span> <span class="n">t_dist</span> <span class="o">==</span> <span class="n">math</span><span class="o">.</span><span class="n">inf</span><span class="p">:</span>
            <span class="n">unvisited</span> <span class="o">+=</span> <span class="mi">1</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;&quot;&quot;Skipped </span><span class="si">{</span><span class="n">unvisited</span><span class="si">}</span><span class="s2"> nodes from a graph with </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">G</span><span class="p">)</span><span class="si">}</span><span class="s2"> total nodes,</span>
<span class="s2">resulting in pruning </span><span class="si">{</span><span class="n">unvisited</span><span class="o">/</span><span class="nb">len</span><span class="p">(</span><span class="n">G</span><span class="p">)</span><span class="o">*</span><span class="mi">100</span><span class="si">}</span><span class="s2">% of the nodes in our search space.&quot;&quot;&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Skipped 7 nodes from a graph with 14 total nodes,
resulting in pruning 50.0% of the nodes in our search space.
</pre></div>
</div>
</div>
</div>
</section>
</section>
<hr class="docutils" />
<section id="example-2-equestrian-statue-to-bahen-centre-using-contraction-hierarchy">
<h3>Example #2: Equestrian Statue to Bahen Centre using Contraction Hierarchy<a class="headerlink" href="#example-2-equestrian-statue-to-bahen-centre-using-contraction-hierarchy" title="Permalink to this heading">#</a></h3>
<p>We can also use the same method to calculate the shortest path between our statue and lecture hall.</p>
<p>Contraction hierarchies typically require incredibly powerful processing resources to run, especially when dealing with larger scales. Our ED function runs in <span class="math notranslate nohighlight">\(O(n^2)\)</span> time, so for a graph of size 1,052 (our University of Toronto map), this requires 1,106,704 runs of <code class="docutils literal notranslate"><span class="pre">dijkstra_with_contraction</span></code>, which itself takes ~0.1 s per call. This would mean just calculating the ED would take 31 hours!</p>
<p>In order to make our example run in a more reasonable amount of time, we are going to reduce the complexity of the search space. Consider the following “simplified” road network:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">osmnx</span>
<span class="kn">import</span> <span class="nn">networkx</span> <span class="k">as</span> <span class="nn">nx</span>
<span class="kn">from</span> <span class="nn">smart_mobility_utilities.viz</span> <span class="kn">import</span> <span class="n">draw_route</span>

<span class="n">reference</span> <span class="o">=</span> <span class="p">(</span><span class="mf">43.661667</span><span class="p">,</span> <span class="o">-</span><span class="mf">79.395</span><span class="p">)</span>

<span class="n">G</span> <span class="o">=</span> <span class="n">osmnx</span><span class="o">.</span><span class="n">graph_from_point</span><span class="p">(</span><span class="n">reference</span><span class="p">,</span> <span class="n">dist</span><span class="o">=</span><span class="mi">300</span><span class="p">,</span> <span class="n">clean_periphery</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">simplify</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">network_type</span><span class="o">=</span><span class="s1">&#39;drive_service&#39;</span><span class="p">)</span>

<span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">osmnx</span><span class="o">.</span><span class="n">plot_graph</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="../../_images/4f9570ce47497334716fcaf8de5d7b2d6bb30463e263ba96585e29d055227212.png" src="../../_images/4f9570ce47497334716fcaf8de5d7b2d6bb30463e263ba96585e29d055227212.png" />
</div>
</div>
<p>This graph only contains 38 nodes and 73 edges, which is much more manageable. We can further remove any self-loops and parallel edges.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Step 1: Remove Parallels and Loops, because Dijkstra doesn&#39;t like that</span>
<span class="n">clean_G</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">DiGraph</span><span class="p">()</span>
<span class="n">clean_G</span><span class="o">.</span><span class="n">clear_edges</span><span class="p">()</span>
<span class="k">for</span> <span class="n">u</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">:</span>
    <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">G</span><span class="p">[</span><span class="n">u</span><span class="p">]:</span>
        <span class="k">if</span> <span class="n">u</span> <span class="o">==</span> <span class="n">v</span><span class="p">:</span> <span class="n">G</span><span class="o">.</span><span class="n">remove_edge</span><span class="p">(</span><span class="n">u</span><span class="p">,</span><span class="n">v</span><span class="p">);</span> <span class="k">continue</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">G</span><span class="p">[</span><span class="n">u</span><span class="p">][</span><span class="n">v</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">keep</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">G</span><span class="p">[</span><span class="n">u</span><span class="p">][</span><span class="n">v</span><span class="p">],</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span><span class="n">G</span><span class="p">[</span><span class="n">u</span><span class="p">][</span><span class="n">v</span><span class="p">][</span><span class="n">x</span><span class="p">][</span><span class="s1">&#39;length&#39;</span><span class="p">])</span>
            <span class="n">keep</span> <span class="o">=</span> <span class="n">G</span><span class="p">[</span><span class="n">u</span><span class="p">][</span><span class="n">v</span><span class="p">][</span><span class="n">keep</span><span class="p">]</span>
            <span class="n">clean_G</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">u</span><span class="p">,</span><span class="n">v</span><span class="p">,</span><span class="o">**</span><span class="n">keep</span><span class="p">)</span>
            <span class="k">continue</span>
        <span class="n">clean_G</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">u</span><span class="p">,</span><span class="n">v</span><span class="p">,</span><span class="o">**</span><span class="n">G</span><span class="p">[</span><span class="n">u</span><span class="p">][</span><span class="n">v</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>

<span class="nb">print</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
<span class="n">G</span> <span class="o">=</span> <span class="n">clean_G</span>
<span class="nb">print</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>MultiDiGraph with 38 nodes and 73 edges
DiGraph with 38 nodes and 71 edges
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Using functions from smart_mobility_utilities, we can generate shortest paths and edge differences very quickly</span>
<span class="kn">from</span> <span class="nn">smart_mobility_utilities.contraction</span> <span class="kn">import</span> <span class="o">*</span>
<span class="n">sp</span> <span class="o">=</span> <span class="n">shortest_paths</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
<span class="n">ed</span> <span class="o">=</span> <span class="n">edge_differences</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">sp</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">edges_before</span> <span class="o">=</span> <span class="p">[</span><span class="o">*</span><span class="n">G</span><span class="o">.</span><span class="n">edges</span><span class="p">()]</span>
<span class="n">contract_graph</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">ed</span><span class="p">,</span><span class="n">sp</span><span class="p">)</span> <span class="c1"># Contract the graph according to ED</span>

<span class="n">edges_after</span> <span class="o">=</span> <span class="p">[</span><span class="o">*</span><span class="n">G</span><span class="o">.</span><span class="n">edges</span><span class="p">()]</span>

<span class="n">added_edges</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">edges_after</span><span class="p">)</span> <span class="o">-</span> <span class="nb">set</span><span class="p">(</span><span class="n">edges_before</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Added edges:&quot;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">added_edges</span><span class="p">))</span>

<span class="c1"># Generate a hierarchy</span>
<span class="n">hierarchical_order</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
<span class="k">for</span> <span class="n">order</span><span class="p">,</span> <span class="n">node</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">ed</span><span class="p">):</span>
    <span class="n">hierarchical_order</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">=</span> <span class="n">order</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Added edges: 768
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Define the start and end</span>
<span class="n">start</span> <span class="o">=</span> <span class="mi">36603405</span>
<span class="n">end</span> <span class="o">=</span> <span class="mi">24959560</span>

<span class="c1"># Generate the upward and downward graphs</span>
<span class="n">up</span><span class="p">,</span> <span class="n">up_SP</span> <span class="o">=</span> <span class="n">generate_dijkstra</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">start</span><span class="p">,</span><span class="n">hierarchical_order</span><span class="p">)</span>
<span class="n">down</span><span class="p">,</span> <span class="n">down_SP</span> <span class="o">=</span> <span class="n">generate_dijkstra</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">end</span><span class="p">,</span><span class="n">hierarchical_order</span><span class="p">,</span><span class="s1">&#39;down&#39;</span><span class="p">)</span>

<span class="n">minimum</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">inf</span>
<span class="n">merge_node</span> <span class="o">=</span> <span class="kc">None</span>

<span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">up_SP</span><span class="p">:</span>
    <span class="k">if</span> <span class="n">x</span> <span class="o">==</span> <span class="n">start</span> <span class="ow">or</span> <span class="n">x</span> <span class="o">==</span> <span class="n">end</span><span class="p">:</span> <span class="k">continue</span>
    <span class="k">if</span> <span class="n">up_SP</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">==</span> <span class="n">math</span><span class="o">.</span><span class="n">inf</span> <span class="ow">or</span> <span class="n">down_SP</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">==</span> <span class="n">math</span><span class="o">.</span><span class="n">inf</span><span class="p">:</span> <span class="k">continue</span>
    <span class="n">total</span> <span class="o">=</span> <span class="n">up_SP</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">+</span> <span class="n">down_SP</span><span class="p">[</span><span class="n">x</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">total</span> <span class="o">&lt;</span> <span class="n">minimum</span><span class="p">:</span> 
        <span class="n">minimum</span> <span class="o">=</span> <span class="n">total</span>
        <span class="n">merge_node</span> <span class="o">=</span> <span class="n">x</span>

<span class="n">route1</span> <span class="o">=</span> <span class="n">build_route</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">start</span><span class="p">,</span><span class="n">merge_node</span><span class="p">,</span><span class="n">up</span><span class="p">)</span>
<span class="n">route2</span> <span class="o">=</span> <span class="n">build_route</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">end</span><span class="p">,</span><span class="n">merge_node</span><span class="p">,</span><span class="n">down</span><span class="p">)</span>
<span class="n">route</span> <span class="o">=</span> <span class="n">route1</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">route2</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
<span class="nb">print</span><span class="p">(</span><span class="n">route</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Cost:&quot;</span><span class="p">,</span> <span class="nb">round</span><span class="p">(</span><span class="n">minimum</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>[36603405, 24960090, 24960068, 24960070, 249991437, 24960080, 5098988924, 854322047, 24959560]
Cost: 848.715
</pre></div>
</div>
</div>
</div>
<p>Once again, we can check to see how much the search space was pruned.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">unvisited</span> <span class="o">=</span> <span class="mi">0</span>
<span class="k">for</span> <span class="n">s_node</span><span class="p">,</span> <span class="n">s_dist</span> <span class="ow">in</span> <span class="n">up_SP</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
    <span class="k">for</span> <span class="n">t_node</span><span class="p">,</span> <span class="n">t_dist</span> <span class="ow">in</span> <span class="n">down_SP</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="k">if</span> <span class="n">s_node</span> <span class="o">==</span> <span class="n">t_node</span> <span class="ow">and</span> <span class="n">s_dist</span> <span class="o">==</span> <span class="n">t_dist</span> <span class="o">==</span> <span class="n">math</span><span class="o">.</span><span class="n">inf</span><span class="p">:</span>
            <span class="n">unvisited</span> <span class="o">+=</span> <span class="mi">1</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;&quot;&quot;Skipped </span><span class="si">{</span><span class="n">unvisited</span><span class="si">}</span><span class="s2"> nodes from a graph with </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">G</span><span class="p">)</span><span class="si">}</span><span class="s2"> total nodes,</span>
<span class="s2">resulting in pruning </span><span class="si">{</span><span class="nb">round</span><span class="p">(</span><span class="n">unvisited</span><span class="o">/</span><span class="nb">len</span><span class="p">(</span><span class="n">G</span><span class="p">)</span><span class="o">*</span><span class="mi">100</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span><span class="si">}</span><span class="s2">% of the nodes in our search space.&quot;&quot;&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output stream highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Skipped 2 nodes from a graph with 38 total nodes,
resulting in pruning 5.263% of the nodes in our search space.
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Reset the Graph</span>
<span class="n">G</span> <span class="o">=</span> <span class="n">osmnx</span><span class="o">.</span><span class="n">graph_from_point</span><span class="p">(</span><span class="n">reference</span><span class="p">,</span> <span class="n">dist</span><span class="o">=</span><span class="mi">300</span><span class="p">,</span> <span class="n">clean_periphery</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">simplify</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">network_type</span><span class="o">=</span><span class="s1">&#39;drive_service&#39;</span><span class="p">)</span>
<span class="n">draw_route</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">route</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<script type="application/vnd.jupyter.widget-view+json">{"model_id": "192f99883572435f9a887f2f136147ff", "version_major": 2, "version_minor": 0}</script></div>
</div>
<p>While this may not look very impressive, the gains from contraction hierarchies are much more pronounced with larger graphs. Typically, larger graphs will entail more impactful contractions that significantly increases the number of pruned nodes. Contraction hierarchies allow larger graphs to run costly algorithms like Dijkstra with a negative space cost. Consider the following:</p>
<ul class="simple">
<li><p>A regular Dijkstra search will need to maintain, with worst-case performance, a list of all traversed nodes and edges. This means a space complexity of <span class="math notranslate nohighlight">\(O(bd)\)</span>.</p></li>
<li><p>A bidirectional implementation of Dijkstra will require a space complexity of <span class="math notranslate nohighlight">\(O(bd/2) + O(bd/2)\)</span>, but has the same time complexity (unless both expansions are run simultaneously, but that has its own complications).</p></li>
<li><p>A contracted bidirectional Dijkstra will improve on both time and space costs, as the search space itself is modified.</p></li>
</ul>
</section>
</section>
</section>

    <script type="text/x-thebe-config">
    {
        requestKernel: true,
        binderOptions: {
            repo: "binder-examples/jupyter-stacks-datascience",
            ref: "master",
        },
        codeMirrorConfig: {
            theme: "abcdef",
            mode: "python"
        },
        kernelOptions: {
            name: "python3",
            path: "./content\GraphSearchAlgorithms"
        },
        predefinedOutput: true
    }
    </script>
    <script>kernelName = 'python3'</script>

                </article>
              

              
              
                <footer class="bd-footer-article">
                  
<div class="footer-article-items footer-article__inner">
  
    <div class="footer-article-item"><!-- Previous / next buttons -->
<div class="prev-next-area">
    <a class="left-prev"
       href="BlindSearch.html"
       title="previous page">
      <i class="fa-solid fa-angle-left"></i>
      <div class="prev-next-info">
        <p class="prev-next-subtitle">previous</p>
        <p class="prev-next-title">Blind Search Algorithms</p>
      </div>
    </a>
    <a class="right-next"
       href="SearchComparison.html"
       title="next page">
      <div class="prev-next-info">
        <p class="prev-next-subtitle">next</p>
        <p class="prev-next-title">Search Algorithm Comparison</p>
      </div>
      <i class="fa-solid fa-angle-right"></i>
    </a>
</div></div>
  
</div>

                </footer>
              
            </div>
            
            
              
                <div class="bd-sidebar-secondary bd-toc"><div class="sidebar-secondary-items sidebar-secondary__inner">

  <div class="sidebar-secondary-item">
  <div class="page-toc tocsection onthispage">
    <i class="fa-solid fa-list"></i> Contents
  </div>
  <nav class="bd-toc-nav page-toc">
    <ul class="visible nav section-nav flex-column">
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#minimum-spanning-tree">Minimum Spanning Tree</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#disjoint-sets">Disjoint Sets</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#parent-array">Parent Array</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#find-algorithm">Find Algorithm</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#minimum-spanning-tree-with-kruskal-s-algorithm">Minimum Spanning Tree with Kruskal’s algorithm</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#hill-climbing">Hill Climbing</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#the-function">The function</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#beam-search">Beam Search</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#a-search">A* Search</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#the-heuristic">The Heuristic</a></li>
</ul>
</li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#bi-directional-search">Bi-Directional Search</a></li>
<li class="toc-h2 nav-item toc-entry"><a class="reference internal nav-link" href="#hierarchical-approaches">Hierarchical Approaches</a><ul class="nav section-nav flex-column">
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#highway-hierarchies">Highway Hierarchies</a></li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#contraction-hierarchies">Contraction Hierarchies</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#contraction">Contraction</a></li>
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#contraction-order">Contraction Order</a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#example-1-bi-directional-dijkstra-with-contraction">Example #1: Bi-directional Dijkstra with contraction</a><ul class="nav section-nav flex-column">
<li class="toc-h4 nav-item toc-entry"><a class="reference internal nav-link" href="#pruning">Pruning</a></li>
</ul>
</li>
<li class="toc-h3 nav-item toc-entry"><a class="reference internal nav-link" href="#example-2-equestrian-statue-to-bahen-centre-using-contraction-hierarchy">Example #2: Equestrian Statue to Bahen Centre using Contraction Hierarchy</a></li>
</ul>
</li>
</ul>
  </nav></div>

</div></div>
              
            
          </div>
          <footer class="bd-footer-content">
            
<div class="bd-footer-content__inner container">
  
  <div class="footer-item">
    
<p class="component-author">
By Alaa Khamis and Yinan Wang
</p>

  </div>
  
  <div class="footer-item">
    
  <p class="copyright">
    
      © Copyright 2021, Alaa Khamis.
      <br/>
    
  </p>

  </div>
  
  <div class="footer-item">
    
  </div>
  
  <div class="footer-item">
    
  </div>
  
</div>
          </footer>
        

      </main>
    </div>
  </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="../../_static/scripts/bootstrap.js?digest=e353d410970836974a52"></script>
<script src="../../_static/scripts/pydata-sphinx-theme.js?digest=e353d410970836974a52"></script>

  <footer class="bd-footer">
  </footer>
  </body>
</html>